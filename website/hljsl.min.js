/**
 * Highlight JS Lite v3.0.0 Copyright (c) 2025 Caboodle Tech Inc.
 * License and source code available at: https://github.com/caboodle-tech/highlight-js-lite
 */
(function () {
    'use strict';

    var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
    class EditableHighlightJS {

        #regex = {
            removeCarriageReturns: /[\r]+/g
        };

        constructor(options = {}) {
            this.activeEditor = null;
            this.cursorX = null;
            this.debounceTimers = new Map();
            this.debounceDelay = options.debounceDelay || 500;
            this.editors = new Set();
            this.multiline = false;
            this.tabSize = options.tabSize || 4;
            this.tabString = ' '.repeat(this.tabSize);
            this.suppressHighlighting = false;
            this.pendingOperations = new Set();
            this.typingAfterSelection = false;

            // History system
            this.history = new Map();
            this.maxHistorySize = options.maxHistorySize || 50;
            this.historyDebounceDelay = options.historyDebounceDelay || 2500;
            this.historyTimers = new Map();
            this.minChangeThreshold = options.minChangeThreshold || 5; // Minimum characters changed

            this.#init();
        }

        /**
         * Initialize the editor system
         */
        #init() {
            document.addEventListener('keydown', this.#handleMultilineKeyDown.bind(this));
            document.addEventListener('keydown', this.#handleHistoryKeyDown.bind(this));
            document.querySelectorAll('pre.editor').forEach((pre) => this.activateEditor(pre));
        }

        /**
         * Activate an editor instance
         * @param {HTMLElement} pre - The pre element containing the editor
         */
        activateEditor(pre) {
            if (this.editors.has(pre)) {
                return;
            }

            const table = pre.querySelector('table');
            if (!table) {
                return;
            }

            let { displayLanguage } = pre.dataset;
            if (!displayLanguage) {
                displayLanguage = Array.from(pre.querySelector('code')?.classList)
                    .find((className) => className.startsWith('language-'))
                    ?.replace('language-', '') || 'Plaintext';
            }

            if (!pre.dataset.editorApplied) {
                const clipboard = pre.querySelector('button.hljsl-clipboard');

                const lang = document.createElement('div');
                lang.classList.add('lang');
                lang.innerText = displayLanguage;

                const div = document.createElement('div');
                div.classList.add('editor-controls');
                div.innerHTML = '<svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M24 10.935v2.131l-8 3.947v-2.23l5.64-2.783-5.64-2.79v-2.223l8 3.948zm-16 3.848l-5.64-2.783 5.64-2.79v-2.223l-8 3.948v2.131l8 3.947v-2.30zm7.047-10.783h-2.078l-4.011 16h2.073l4.016-16z"/></svg>';
                div.appendChild(lang);
                div.appendChild(clipboard);
                pre.insertAdjacentElement('beforebegin', div);

                pre.dataset.editorApplied = true;
            } else {
                const lang = pre.previousElementSibling.querySelector('.lang');
                if (lang) {
                    lang.innerText = displayLanguage;
                }
            }

            const debounceHandler = this.#createDebounceHandler(pre);
            pre._debounceHandler = debounceHandler;

            this.editors.add(pre);
            table.addEventListener('keyup', debounceHandler);
            table.addEventListener('keydown', this.#handleKeyDown.bind(this));
            table.addEventListener('mousedown', this.#handleMouseDown.bind(this));
            table.addEventListener('paste', this.#handlePastedContent.bind(this));
            table.addEventListener('mouseup', this.#handleMouseUp.bind(this));

            // Make the second column editable
            for (const row of table.rows) {
                const codeCell = row.cells[1];
                if (codeCell) codeCell.contentEditable = true;
            }

            this.#initializeHistory(pre);
        }

        /**
         * Create debounce handler for highlighting updates
         * @param {HTMLElement} pre - The pre element
         * @returns {Function} The debounce handler
         */
        #createDebounceHandler(pre) {
            return (event) => {
                if (this.suppressHighlighting || this.multiline || this.pendingOperations.size > 0 || this.typingAfterSelection) {
                    return;
                }

                if (event && event.type === 'keyup') {
                    const { key } = event;
                    const hasModifier = event.ctrlKey || event.metaKey || event.altKey;

                    if (hasModifier ||
                        ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End', 'PageUp', 'PageDown'].includes(key)) {
                        return;
                    }

                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        if (!range.collapsed && selection.toString().includes('\n')) {
                            return;
                        }
                    }
                }

                const existingTimer = this.debounceTimers.get(pre);
                if (existingTimer) {
                    clearTimeout(existingTimer);
                }

                const timerId = setTimeout(() => {
                    if (!this.suppressHighlighting && !this.multiline && this.pendingOperations.size === 0) {
                        this.updateEditor(pre);
                    }
                    this.debounceTimers.delete(pre);
                }, this.debounceDelay);

                this.debounceTimers.set(pre, timerId);
            };
        }

        /**
         * Temporarily suppress highlighting during operations
         * @param {Function} callback - The operation to perform
         * @param {number} duration - Duration to suppress highlighting
         * @returns {*} The result of the callback
         */
        withSuppressedHighlighting(callback, duration = 1000) {
            this.suppressHighlighting = true;
            try {
                const result = callback();
                if (result instanceof Promise) {
                    return result.finally(() => {
                        setTimeout(() => {
                            this.suppressHighlighting = false;
                        }, duration);
                    });
                }
                return result;
            } finally {
                setTimeout(() => {
                    this.suppressHighlighting = false;
                }, duration);
            }
        }

        /**
         * Track operations that should suppress highlighting
         * @param {string} operationId - Unique operation identifier
         */
        addPendingOperation(operationId) {
            this.pendingOperations.add(operationId);
            setTimeout(() => {
                this.pendingOperations.delete(operationId);
            }, 2000);
        }

        /**
         * Remove pending operation
         * @param {string} operationId - Operation identifier to remove
         */
        removePendingOperation(operationId) {
            this.pendingOperations.delete(operationId);
        }

        /**
         * Initialize history system for an editor
         * @param {HTMLElement} pre - The pre element
         */
        #initializeHistory(pre) {
            const editorId = pre.dataset.hljslId || this.createId();
            if (!pre.dataset.hljslId) {
                pre.dataset.hljslId = editorId;
            }

            if (!this.history.has(editorId)) {
                this.history.set(editorId, {
                    states: [],
                    currentIndex: -1
                });

                // Create initial state with cursor at end
                const table = pre.querySelector('table');
                const lines = Array.from(table.rows).map((row) => row.cells[1].textContent);
                const lastRowIndex = lines.length - 1;
                const lastLineLength = lines[lastRowIndex] ? lines[lastRowIndex].length : 0;

                const initialState = {
                    lines,
                    cursorPosition: {
                        rowIndex: lastRowIndex,
                        columnPosition: lastLineLength
                    },
                    timestamp: Date.now()
                };

                this.history.get(editorId).states.push(initialState);
                this.history.get(editorId).currentIndex = 0;
            }
        }

        /**
         * Get current cursor position information - improved version
         * @param {HTMLElement} pre - The pre element
         * @returns {Object|null} Cursor position information
         */
        #getCurrentCursorPosition(pre) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return null;

            const range = selection.getRangeAt(0);
            const { activeElement } = document;

            // Make sure we're in a content cell
            if (!pre.contains(activeElement)) {
                return null;
            }

            // Find the actual cell - could be the TD itself or a child element
            const cell = activeElement.tagName === 'TD' ? activeElement : activeElement.closest('td');
            if (!cell || cell.cellIndex !== 1) { // Ensure it's the content cell (index 1)
                return null;
            }

            const table = pre.querySelector('table');
            const row = cell.closest('tr');
            const rowIndex = Array.from(table.rows).indexOf(row);

            // Calculate position within the cell's text content
            const columnPosition = this.#getCursorPosition(cell, range);

            return {
                rowIndex,
                columnPosition
            };
        }

        /**
         * Get current editor state
         * @param {HTMLElement} pre - The pre element
         * @returns {Object|null} The current state
         */
        #getCurrentEditorState(pre) {
            const table = pre.querySelector('table');
            if (!table) return null;

            const lines = Array.from(table.rows).map((row) => {
                if (row.cells[1]) {
                    return row.cells[1].textContent;
                }
                return '';
            });

            const cursorPosition = this.#getCurrentCursorPosition(pre);

            return {
                lines,
                cursorPosition,
                timestamp: Date.now()
            };
        }

        /**
         * Calculate the amount of change between two states
         * @param {Object} state1 - First state
         * @param {Object} state2 - Second state
         * @returns {number} Number of changed characters
         */
        #calculateChangeAmount(state1, state2) {
            if (!state1 || !state2) return Infinity;

            const text1 = state1.lines.join('\n');
            const text2 = state2.lines.join('\n');

            // Simple diff calculation - count different characters
            let changes = Math.abs(text1.length - text2.length);
            const minLength = Math.min(text1.length, text2.length);

            for (let i = 0; i < minLength; i++) {
                if (text1[i] !== text2[i]) {
                    changes++;
                }
            }

            return changes;
        }

        /**
         * Save current state to history
         * @param {HTMLElement} pre - The pre element
         * @param {boolean} immediate - Whether to save immediately or debounce
         * @param {boolean} force - Whether to force save regardless of change threshold
         */
        #saveToHistory(pre, immediate = false, force = false) {
            const editorId = pre.dataset.hljslId;
            if (!editorId) return;

            if (immediate) {
                this.#doSaveToHistory(pre, force);
            } else {
                const existingTimer = this.historyTimers.get(editorId);
                if (existingTimer) {
                    clearTimeout(existingTimer);
                }

                const timerId = setTimeout(() => {
                    this.#doSaveToHistory(pre, force);
                    this.historyTimers.delete(editorId);
                }, this.historyDebounceDelay);

                this.historyTimers.set(editorId, timerId);
            }
        }

        /**
         * Actually save to history
         * @param {HTMLElement} pre - The pre element
         * @param {boolean} force - Whether to force save regardless of change threshold
         */
        #doSaveToHistory(pre, force = false) {
            const editorId = pre.dataset.hljslId;
            const historyData = this.history.get(editorId);
            if (!historyData) return;

            const currentState = this.#getCurrentEditorState(pre);
            if (!currentState) return;

            if (historyData.states.length > 0) {
                const lastState = historyData.states[historyData.currentIndex];

                // Check if states are exactly equal
                if (this.#statesEqual(currentState, lastState)) {
                    return;
                }

                // Check if enough has changed to warrant a new history entry (unless forced)
                if (!force) {
                    const changeAmount = this.#calculateChangeAmount(currentState, lastState);
                    if (changeAmount < this.minChangeThreshold) {
                        return;
                    }
                }
            }

            if (historyData.currentIndex < historyData.states.length - 1) {
                historyData.states = historyData.states.slice(0, historyData.currentIndex + 1);
            }

            historyData.states.push(currentState);
            historyData.currentIndex = historyData.states.length - 1;

            if (historyData.states.length > this.maxHistorySize) {
                historyData.states.shift();
                historyData.currentIndex -= 1;
            }
        }

        /**
         * Check if two states are equal
         * @param {Object} state1 - First state
         * @param {Object} state2 - Second state
         * @returns {boolean} Whether states are equal
         */
        #statesEqual(state1, state2) {
            if (state1.lines.length !== state2.lines.length) return false;
            for (let i = 0; i < state1.lines.length; i++) {
                if (state1.lines[i] !== state2.lines[i]) return false;
            }
            return true;
        }

        /**
         * Get the total text content length of a cell (ignoring HTML markup)
         * @param {HTMLElement} cell - The cell element
         * @returns {number} The total text length
         */
        #getTextContentLength(cell) {
            const walker = document.createTreeWalker(cell, NodeFilter.SHOW_TEXT);
            let total = 0;
            let node;
            while (node = walker.nextNode()) {
                total += node.textContent.length;
            }
            return total;
        }

        /**
         * Restore cursor position after state restoration
         * @param {HTMLElement} pre - The pre element
         * @param {Object} cursorPosition - The cursor position to restore
         */
        #restoreCursorPosition(pre, cursorPosition) {
            if (!cursorPosition) return;

            const table = pre.querySelector('table');
            if (!table || cursorPosition.rowIndex < 0 || cursorPosition.rowIndex >= table.rows.length) {
                return;
            }

            const targetRow = table.rows[cursorPosition.rowIndex];
            const targetCell = targetRow.cells[1];
            if (!targetCell) return;

            targetCell.contentEditable = true;
            targetCell.focus();

            // Ensure cursor position is within bounds of the actual text content
            // This accounts for any changes made by syntax highlighting
            const actualTextLength = this.#getTextContentLength(targetCell);
            const safePosition = Math.min(cursorPosition.columnPosition || 0, actualTextLength);

            this.#setCursorPosition(targetCell, safePosition);
        }

        /**
         * Undo operation
         * @param {HTMLElement} pre - The pre element
         * @returns {boolean} Whether undo was successful
         */
        undo(pre) {
            const editorId = pre.dataset.hljslId;
            const historyData = this.history.get(editorId);
            if (!historyData || historyData.currentIndex <= 0) {
                return false;
            }

            historyData.currentIndex -= 1;
            const targetState = historyData.states[historyData.currentIndex];

            this.#restoreEditorState(pre, targetState);
            return true;
        }

        /**
         * Redo operation
         * @param {HTMLElement} pre - The pre element
         * @returns {boolean} Whether redo was successful
         */
        redo(pre) {
            const editorId = pre.dataset.hljslId;
            const historyData = this.history.get(editorId);
            if (!historyData || historyData.currentIndex >= historyData.states.length - 1) {
                return false;
            }

            historyData.currentIndex += 1;
            const targetState = historyData.states[historyData.currentIndex];

            this.#restoreEditorState(pre, targetState);
            return true;
        }

        /**
         * Restore editor state
         * @param {HTMLElement} pre - The pre element
         * @param {Object} state - The state to restore
         */
        #restoreEditorState(pre, state) {
            const table = pre.querySelector('table');
            if (!table) return;

            const fragment = document.createDocumentFragment();

            state.lines.forEach((lineContent, index) => {
                const row = document.createElement('tr');

                const lineNumCell = document.createElement('td');
                lineNumCell.textContent = index + 1;

                const contentCell = document.createElement('td');
                contentCell.contentEditable = true;
                contentCell.textContent = lineContent;

                row.appendChild(lineNumCell);
                row.appendChild(contentCell);
                fragment.appendChild(row);
            });

            table.innerHTML = '';
            table.appendChild(fragment);

            // Apply highlighting first, then position cursor
            if (window.hljsl) {
                window.hljsl.highlight(pre);
            }

            // Position cursor after highlighting is complete
            // Use setTimeout to ensure highlighting DOM changes are applied
            setTimeout(() => {
                this.#restoreCursorPosition(pre, state.cursorPosition);
            }, 10);
        }

        /**
         * Handle history keyboard shortcuts
         * @param {KeyboardEvent} event - The keyboard event
         */
        #handleHistoryKeyDown(event) {
            if ((event.ctrlKey || event.metaKey) && (event.key === 'z' || event.key === 'Z')) {
                if (event.shiftKey || (event.ctrlKey && event.key === 'y') || (event.ctrlKey && event.key === 'Y')) {
                    event.preventDefault();
                    const activeCell = document.activeElement;
                    const pre = activeCell.closest('pre.editor');
                    if (pre) {
                        this.redo(pre);
                    }
                } else {
                    event.preventDefault();
                    const activeCell = document.activeElement;
                    const pre = activeCell.closest('pre.editor');
                    if (pre) {
                        this.undo(pre);
                    }
                }
                return;
            }

            if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || event.key === 'Y')) {
                event.preventDefault();
                const activeCell = document.activeElement;
                const pre = activeCell.closest('pre.editor');
                if (pre) {
                    this.redo(pre);
                }
                return;
            }
        }

        /**
         * Get cursor column position - improved version
         * @param {HTMLElement} cell - The cell element
         * @param {Range} [range] - The selection range (optional, defaults to current selection)
         * @returns {number} The column position
         */
        #getCursorPosition(cell, range) {
            if (!range) {
                const selection = window.getSelection();
                if (!selection.rangeCount) return 0;
                range = selection.getRangeAt(0);
            }

            const walker = document.createTreeWalker(cell, NodeFilter.SHOW_TEXT);
            let total = 0;
            let node;

            while (node = walker.nextNode()) {
                if (node === range.startContainer) {
                    return total + range.startOffset;
                }
                total += node.textContent.length;
            }

            // If we didn't find the start container, return the total length
            return total;
        }

        /**
         * Set cursor column (offset) position - improved version
         * @param {HTMLElement} cell - The cell element
         * @param {number} position - The column position
         */
        #setCursorPosition(cell, position) {
            // Ensure the cell is focused first
            if (document.activeElement !== cell) {
                cell.focus();
            }

            const walker = document.createTreeWalker(cell, NodeFilter.SHOW_TEXT);
            let total = 0;
            let node;

            while (node = walker.nextNode()) {
                const len = node.textContent.length;
                if (total + len >= position) {
                    const offset = Math.max(0, Math.min(position - total, len));
                    this.#setCursorOffset(node, offset);
                    return;
                }
                total += len;
            }

            // Fallback: position at the end
            const fallback = this.#getLastTextNode(cell);
            if (fallback) {
                this.#setCursorOffset(fallback, fallback.textContent.length);
            } else {
                // Create a text node if none exists
                const textNode = document.createTextNode('');
                cell.appendChild(textNode);
                this.#setCursorOffset(textNode, 0);
            }
        }

        /**
         * Replace current selection with text
         * @param {string} text - Text to insert
         * @param {HTMLElement} targetCell - The target cell
         * @param {HTMLElement} pre - The pre element
         */
        #replaceSelection(text, targetCell, pre) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            const range = selection.getRangeAt(0);

            // Save to history before making changes - force save for selection replacement
            this.#saveToHistory(pre, true, !range.collapsed);

            if (range.collapsed) {
                // No selection, just insert text at cursor
                const textNode = range.startContainer.nodeType === 3 ?
                    range.startContainer :
                    range.startContainer.firstChild || range.startContainer.appendChild(document.createTextNode(''));

                const offset = range.startOffset;
                textNode.textContent = textNode.textContent.slice(0, offset) + text + textNode.textContent.slice(offset);
                this.#setCursorOffset(textNode, offset + text.length);
            } else {
                // Replace selection with text
                range.deleteContents();
                const textNode = document.createTextNode(text);
                range.insertNode(textNode);
                this.#setCursorOffset(textNode, text.length);
            }
        }

        /**
         * Handle pasted content
         * @param {ClipboardEvent} event - The paste event
         */
        #handlePastedContent(event) {
            event.preventDefault();

            // Clear any multiline/selection states that might interfere
            this.activeEditor = null;
            this.multiline = false;
            this.typingAfterSelection = false;

            const operationId = `paste-${Date.now()}`;
            this.addPendingOperation(operationId);

            const clipboardData = event.clipboardData || window.clipboardData;
            const pastedContent = clipboardData.getData('text');
            const targetCell = event.target;

            if (!targetCell || !pastedContent) {
                this.removePendingOperation(operationId);
                return;
            }

            const table = targetCell.closest('table');
            const pre = table.closest('pre');

            // Clear any existing debounce timers to prevent conflicts
            const existingTimer = this.debounceTimers.get(pre);
            if (existingTimer) {
                clearTimeout(existingTimer);
                this.debounceTimers.delete(pre);
            }

            this.#saveToHistory(pre, true, true); // Force save for paste operations

            const cleanContent = pastedContent.replace(this.#regex.removeCarriageReturns, '');
            const lines = cleanContent.split('\n');

            // Check if there's a selection and handle it
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                if (!range.collapsed) {
                    // There's a selection, delete it first
                    const { startContainer, endContainer, startOffset, endOffset } = range;

                    const startRow = startContainer.nodeType === 3 ?
                        startContainer.parentNode.closest('tr') :
                        startContainer.closest('tr');
                    const endRow = endContainer.nodeType === 3 ?
                        endContainer.parentNode.closest('tr') :
                        endContainer.closest('tr');

                    if (startRow && endRow) {
                        const rows = Array.from(table.rows);
                        const startIndex = rows.indexOf(startRow);
                        const endIndex = rows.indexOf(endRow);

                        const startCell = startRow.cells[1];
                        const endCell = endRow.cells[1];

                        // Get text before selection
                        let startCellTextBefore = '';
                        const startTextNodes = this.#getTextNodes(startCell);
                        let startNodeIdx = 0;

                        while (startNodeIdx < startTextNodes.length) {
                            const node = startTextNodes[startNodeIdx];
                            if (node === startContainer) {
                                startCellTextBefore += node.textContent.substring(0, startOffset);
                                break;
                            } else {
                                startCellTextBefore += node.textContent;
                            }
                            startNodeIdx += 1;
                        }

                        // Get text after selection
                        let endCellTextAfter = '';
                        const endTextNodes = this.#getTextNodes(endCell);
                        let endNodeIdx = 0;

                        while (endNodeIdx < endTextNodes.length) {
                            const node = endTextNodes[endNodeIdx];
                            if (node === endContainer) {
                                endCellTextAfter += node.textContent.substring(endOffset);
                                endNodeIdx += 1;
                                break;
                            }
                            endNodeIdx += 1;
                        }

                        while (endNodeIdx < endTextNodes.length) {
                            endCellTextAfter += endTextNodes[endNodeIdx].textContent;
                            endNodeIdx += 1;
                        }

                        // Replace selection with pasted content
                        let lastModifiedRow = startRow; // Track the last row we actually modified

                        if (startIndex === endIndex) {
                            // Single line selection
                            const firstLine = lines.shift() || '';
                            startCell.textContent = startCellTextBefore + firstLine;

                            if (lines.length > 0) {
                                // Multi-line paste into single line selection
                                lines.forEach((line, index) => {
                                    const isLastLine = index === lines.length - 1;
                                    const lineContent = isLastLine ? line + endCellTextAfter : line;

                                    const newRow = document.createElement('tr');
                                    const lineNumCell = document.createElement('td');
                                    const contentCell = document.createElement('td');
                                    contentCell.contentEditable = true;
                                    contentCell.textContent = lineContent;

                                    newRow.appendChild(lineNumCell);
                                    newRow.appendChild(contentCell);
                                    lastModifiedRow.insertAdjacentElement('afterend', newRow);
                                    lastModifiedRow = newRow; // Update tracker
                                });
                            } else {
                                // Single line paste into single line selection
                                startCell.textContent += endCellTextAfter;
                            }
                        } else {
                            // Multi-line selection
                            const firstLine = lines.shift() || '';
                            startCell.textContent = startCellTextBefore + firstLine;

                            // Remove rows between start and end (exclusive)
                            for (let i = endIndex - 1; i > startIndex; i--) {
                                rows[i].remove();
                            }

                            if (lines.length > 0) {
                                // Insert new lines
                                lines.forEach((line, index) => {
                                    const isLastLine = index === lines.length - 1;
                                    const lineContent = isLastLine ? line + endCellTextAfter : line;

                                    const newRow = document.createElement('tr');
                                    const lineNumCell = document.createElement('td');
                                    const contentCell = document.createElement('td');
                                    contentCell.contentEditable = true;
                                    contentCell.textContent = lineContent;

                                    newRow.appendChild(lineNumCell);
                                    newRow.appendChild(contentCell);
                                    lastModifiedRow.insertAdjacentElement('afterend', newRow);
                                    lastModifiedRow = newRow; // Update tracker
                                });

                                // Remove the original end row since we've incorporated its remaining text
                                if (endRow.parentNode) {
                                    endRow.remove();
                                }
                            } else {
                                // No additional lines, just append remaining text to start cell
                                startCell.textContent += endCellTextAfter;
                                if (endRow.parentNode) {
                                    endRow.remove();
                                }
                            }
                        }

                        this.#updateLineNumbers(table);

                        // Simple: focus the actual last row we modified and position cursor
                        // at end of pasted content (before any trailing text)
                        const finalCell = lastModifiedRow.cells[1];
                        if (finalCell) {
                            finalCell.focus();
                            const cellText = finalCell.textContent;
                            const cursorPos = endCellTextAfter.length > 0 ?
                                cellText.length - endCellTextAfter.length :
                                cellText.length;
                            this.#setCursorPosition(finalCell, cursorPos);
                        }

                        // Single highlight call after paste completion
                        this.#completePasteOperation(pre, operationId);
                        return;
                    }
                }
            }

            // No selection or single cursor position - original behavior
            targetCell.textContent = lines.shift();
            let lastRow = targetCell.closest('tr');

            lines.forEach((line) => {
                const newRow = document.createElement('tr');
                const lineNumCell = document.createElement('td');
                const contentCell = document.createElement('td');
                contentCell.contentEditable = true;
                contentCell.textContent = line;

                newRow.appendChild(lineNumCell);
                newRow.appendChild(contentCell);
                lastRow.insertAdjacentElement('afterend', newRow);
                lastRow = newRow;
            });

            this.#updateLineNumbers(table);

            const lastCell = lastRow.cells[1];
            if (lastCell) {
                const lastTextNode = this.#getLastTextNode(lastCell);
                if (lastTextNode) {
                    const range = document.createRange();
                    const sel = window.getSelection();
                    range.setStart(lastTextNode, lastTextNode.length);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                } else {
                    const emptyTextNode = document.createTextNode('');
                    lastCell.appendChild(emptyTextNode);
                    const range = document.createRange();
                    const sel = window.getSelection();
                    range.setStart(emptyTextNode, 0);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
                lastCell.focus();
            }

            // Single highlight call after paste completion
            this.#completePasteOperation(pre, operationId);
        }

        /**
         * Complete paste operation with single highlight call
         * @param {HTMLElement} pre - The pre element
         * @param {string} operationId - The operation ID to remove
         */
        #completePasteOperation(pre, operationId) {
            // Use setTimeout to ensure DOM has settled
            setTimeout(() => {
                this.removePendingOperation(operationId);
                // Single, definitive highlight call
                if (window.hljsl) {
                    window.hljsl.highlight(pre);
                }
            }, 150);
        }

        /**
         * Handle keydown events
         * @param {KeyboardEvent} event - The keyboard event
         */
        #handleKeyDown(event) {
            // Exit typing mode for navigation keys
            if (this.typingAfterSelection && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End', 'Tab', 'Enter'].includes(event.key)) {
                this.typingAfterSelection = false;
                this.activeEditor = null;
                this.multiline = false;
            }

            const cell = event.target;
            const row = cell.closest('tr');
            const table = row.closest('table');
            const pre = table.closest('pre');
            if (!cell.isContentEditable) return;

            const selection = window.getSelection();
            const range = selection.getRangeAt(0);

            // Handle regular character input - this fixes the selection replacement issue
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                event.preventDefault();
                this.#replaceSelection(event.key, cell, pre);
                return;
            }

            if ((event.key === 'a' || event.key === 'A') && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();

                // Clear any existing pending operations to prevent conflicts
                this.pendingOperations.clear();

                const operationId = `select-all-${Date.now()}`;
                this.addPendingOperation(operationId);

                if (table) {
                    const range = document.createRange();
                    const firstRow = table.rows[0];
                    const firstCell = firstRow.cells[1];
                    const firstTextNode = this.#getTextNodes(firstCell)[0];

                    const lastRow = table.rows[table.rows.length - 1];
                    const lastCell = lastRow.cells[1];
                    const textNodes = this.#getTextNodes(lastCell);
                    const lastTextNode = textNodes[textNodes.length - 1];

                    if (firstTextNode && lastTextNode) {
                        range.setStart(firstTextNode, 0);
                        range.setEnd(lastTextNode, lastTextNode.textContent.length);

                        selection.removeAllRanges();
                        selection.addRange(range);

                        this.activeEditor = pre;
                        this.multiline = true;
                    }
                }

                setTimeout(() => {
                    this.removePendingOperation(operationId);
                }, 100);

                return;
            }

            if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                event.preventDefault();
                const rows = Array.from(table.rows);
                const currentIndex = rows.indexOf(row);
                const targetIndex = event.key === 'ArrowUp' ? currentIndex - 1 : currentIndex + 1;

                if (this.cursorX === null) {
                    this.cursorX = this.#getCursorPosition(cell, range);
                }

                if (targetIndex >= 0 && targetIndex < rows.length) {
                    const targetCell = rows[targetIndex].cells[1];
                    const targetTextLength = targetCell.textContent ? targetCell.textContent.length : 0;

                    if (this.cursorX <= targetTextLength) {
                        this.#setCursorPosition(targetCell, this.cursorX);
                    } else {
                        const fallbackColumn = event.key === 'ArrowUp' ? 0 : targetTextLength;
                        this.#setCursorPosition(targetCell, fallbackColumn);
                    }
                }
                return;
            }

            this.cursorX = null;

            if (event.key === 'Tab') {
                event.preventDefault();
                this.#saveToHistory(pre, true, true); // Force save for tab operations

                const { startContainer, startOffset } = range;
                const node = startContainer.nodeType === 3 ? startContainer : startContainer.firstChild;
                if (!node) return;
                if (event.shiftKey) {
                    const text = node.textContent;
                    const indentMatch = text.slice(0, startOffset).match(/^ +/);
                    const currentIndent = indentMatch ? indentMatch[0].length : 0;
                    const removeCount = Math.min(this.tabSize, currentIndent);
                    node.textContent = text.slice(0, startOffset - removeCount) + text.slice(startOffset);
                    this.#setCursorOffset(node, startOffset - removeCount);
                } else {
                    node.textContent = node.textContent.slice(0, startOffset) + this.tabString + node.textContent.slice(startOffset);
                    this.#setCursorOffset(node, startOffset + this.tabSize);
                }
            } else if (event.key === 'Enter') {
                event.preventDefault();
                this.#saveToHistory(pre, true, true); // Force save for enter operations

                const { startContainer, startOffset } = range;
                const node = startContainer;
                const currentTextNode = node.nodeType === 3 ? node : node.firstChild;
                let indent = '';
                const walker = document.createTreeWalker(cell, NodeFilter.SHOW_TEXT);
                const firstTextNode = walker.nextNode();
                if (firstTextNode) {
                    const match = firstTextNode.textContent.match(/^\s*/);
                    indent = match ? match[0] : '';
                }
                const newRow = row.cloneNode(true);
                const newCell = newRow.cells[1];
                newCell.innerHTML = '';
                if (currentTextNode && currentTextNode.nodeType === 3) {
                    const before = currentTextNode.textContent.slice(0, startOffset);
                    const after = currentTextNode.textContent.slice(startOffset);
                    currentTextNode.textContent = before;
                    const afterNode = document.createTextNode(indent + after);
                    newCell.appendChild(afterNode);
                    let sibling = currentTextNode.parentNode.nextSibling;
                    while (sibling) {
                        const next = sibling.nextSibling;
                        newCell.appendChild(sibling);
                        sibling = next;
                    }
                }
                row.parentNode.insertBefore(newRow, row.nextSibling);
                this.#updateLineNumbers(table);
                this.#focusCell(newCell, indent.length);
            } else if (event.key === 'Backspace') {
                const cursorPos = range.startOffset;
                if (cursorPos === 0 && row.previousElementSibling) {
                    event.preventDefault();
                    this.#saveToHistory(pre, true, true); // Force save for backspace operations

                    const prevRow = row.previousElementSibling;
                    const prevCell = prevRow.cells[1];
                    const textNodes = this.#getTextNodes(cell);
                    let mergedText = '';
                    for (const node of textNodes) {
                        mergedText += node.textContent;
                    }
                    const lastNode = this.#getLastTextNode(prevCell);
                    if (lastNode) {
                        const offset = lastNode.textContent.length;
                        lastNode.textContent += mergedText;
                        row.remove();
                        this.#updateLineNumbers(table);
                        this.#setCursorOffset(lastNode, offset);
                    } else {
                        prevCell.appendChild(document.createTextNode(mergedText));
                        row.remove();
                        this.#updateLineNumbers(table);
                        this.#focusCell(prevCell, prevCell.textContent.length);
                    }
                } else {
                    // Handle selection deletion for backspace
                    if (!range.collapsed) {
                        event.preventDefault();
                        this.#saveToHistory(pre, true, true); // Force save for selection deletion
                        range.deleteContents();
                    } else {
                        cell.contentEditable = true;
                        cell.focus();
                        range.deleteContents();
                        this.#setCursorOffset(range.startContainer, range.startOffset);
                    }
                }

                this.#removeMalformedRows(table);
            } else if (event.key === 'Delete') {
                // Handle selection deletion for delete key
                if (!range.collapsed) {
                    event.preventDefault();
                    this.#saveToHistory(pre, true, true); // Force save for delete operations
                    range.deleteContents();
                }
            }
        }

        /**
         * Handle multiline keyboard operations
         * @param {KeyboardEvent} event - The keyboard event
         */
        #handleMultilineKeyDown(event) {
            if (!this.multiline || !this.activeEditor) {
                return;
            }

            // Handle continued typing after selection deletion
            if (this.typingAfterSelection && event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                event.preventDefault();

                // Reset the timer
                this.typingAfterSelection = false;
                setTimeout(() => {
                    if (!this.typingAfterSelection) {
                        this.activeEditor = null;
                        this.multiline = false;
                    }
                }, 100);
                this.typingAfterSelection = true;

                // Insert character at current cursor position
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const textNode = range.startContainer;
                    const offset = range.startOffset;

                    if (textNode.nodeType === 3) {
                        textNode.textContent = textNode.textContent.slice(0, offset) + event.key + textNode.textContent.slice(offset);
                        this.#setCursorOffset(textNode, offset + 1);
                    }
                }
                return;
            }

            // Exit typing mode for any other key
            if (this.typingAfterSelection) {
                this.typingAfterSelection = false;
                this.activeEditor = null;
                this.multiline = false;
                return;
            }

            const isMultilineOperation = ['c', 'C', 'x', 'X', 'Tab', 'Backspace', 'Delete', 'Enter', 'Escape'].includes(event.key) ||
                                        (event.ctrlKey || event.metaKey) ||
                                        (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey);

            if (isMultilineOperation) {
                const operationId = `multiline-${event.key}-${Date.now()}`;
                this.addPendingOperation(operationId);
                setTimeout(() => {
                    this.removePendingOperation(operationId);
                }, 200);
            }

            if ((event.key === 'c' || event.key === 'C') && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();

                const selection = window.getSelection();
                const range = selection.getRangeAt(0);
                const { startContainer, endContainer } = range;

                const startRow = startContainer.nodeType === 3 ?
                    startContainer.parentNode.closest('tr') :
                    startContainer.closest('tr');
                const endRow = endContainer.nodeType === 3 ?
                    endContainer.parentNode.closest('tr') :
                    endContainer.closest('tr');

                if (!startRow && !endRow) return;

                const table = startRow.closest('table');
                const rows = Array.from(table.rows);
                const startIndex = rows.indexOf(startRow);
                const endIndex = rows.indexOf(endRow);

                let selectedText = '';
                for (let i = Math.min(startIndex, endIndex); i <= Math.max(startIndex, endIndex); i++) {
                    const cell = rows[i].cells[1];
                    if (!cell) continue;
                    selectedText += `${cell.textContent}\n`;
                }
                selectedText = selectedText.trim() || '';

                navigator.clipboard.writeText(selectedText);
                return;
            }

            if ((event.key === 'x' || event.key === 'X') && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();

                const selection = window.getSelection();
                const range = selection.getRangeAt(0);
                const { startContainer, endContainer } = range;

                const startRow = startContainer.nodeType === 3 ?
                    startContainer.parentNode.closest('tr') :
                    startContainer.closest('tr');
                const endRow = endContainer.nodeType === 3 ?
                    endContainer.parentNode.closest('tr') :
                    endContainer.closest('tr');

                if (!startRow && !endRow) return;

                const table = startRow.closest('table');
                const pre = table.closest('pre');
                const rows = Array.from(table.rows);
                const startIndex = rows.indexOf(startRow);
                const endIndex = rows.indexOf(endRow);

                let selectedText = '';
                for (let i = Math.min(startIndex, endIndex); i <= Math.max(startIndex, endIndex); i++) {
                    const cell = rows[i].cells[1];
                    if (!cell) continue;
                    selectedText += `${cell.textContent}\n`;
                }
                selectedText = selectedText.trim() || '';

                navigator.clipboard.writeText(selectedText);

                // Now delete the selection (same logic as Delete/Backspace)
                this.#saveToHistory(pre, true, true); // Force save for cut operations

                const { startOffset, endOffset } = range;
                const startCell = startRow.cells[1];
                const endCell = endRow.cells[1];

                let startCellTextBefore = '';
                const startTextNodes = this.#getTextNodes(startCell);
                let startNodeIdx = 0;

                while (startNodeIdx < startTextNodes.length) {
                    const node = startTextNodes[startNodeIdx];
                    if (node === startContainer) {
                        startCellTextBefore += node.textContent.substring(0, startOffset);
                        break;
                    } else {
                        startCellTextBefore += node.textContent;
                    }
                    startNodeIdx += 1;
                }

                let endCellTextAfter = '';
                const endTextNodes = this.#getTextNodes(endCell);
                let endNodeIdx = 0;

                while (endNodeIdx < endTextNodes.length) {
                    const node = endTextNodes[endNodeIdx];
                    if (node === endContainer) {
                        endCellTextAfter += node.textContent.substring(endOffset);
                        endNodeIdx += 1;
                        break;
                    }
                    endNodeIdx += 1;
                }

                while (endNodeIdx < endTextNodes.length) {
                    endCellTextAfter += endTextNodes[endNodeIdx].textContent;
                    endNodeIdx += 1;
                }

                if (startIndex === endIndex) {
                    startCell.textContent = startCellTextBefore + endCellTextAfter;
                } else {
                    startCell.textContent = startCellTextBefore + endCellTextAfter;
                    for (let i = endIndex; i > startIndex; i--) {
                        rows[i].remove();
                    }
                    this.#updateLineNumbers(table);
                }

                this.#removeMalformedRows(table);

                if (table.rows.length === 0) {
                    const newRow = document.createElement('tr');
                    newRow.innerHTML = '<td>1</td><td contenteditable="true"></td>';
                    table.appendChild(newRow);
                    this.#updateLineNumbers(table);
                }

                startCell.contentEditable = true;
                startCell.focus();
                this.#setCursorPosition(startCell, startCellTextBefore.length);

                this.activeEditor = null;
                this.multiline = false;

                if (window.hljsl) {
                    window.hljsl.highlight(pre);
                }

                return;
            }

            if (event.key === 'Tab') {
                const selection = window.getSelection();
                const range = selection.getRangeAt(0);
                const { startContainer, endContainer } = range;

                const startRow = startContainer.nodeType === 3 ?
                    startContainer.parentNode.closest('tr') :
                    startContainer.closest('tr');
                const endRow = endContainer.nodeType === 3 ?
                    endContainer.parentNode.closest('tr') :
                    endContainer.closest('tr');

                if (!startRow && !endRow) return;

                const table = startRow.closest('table');
                const pre = table.closest('pre');
                const rows = Array.from(table.rows);
                const startIndex = rows.indexOf(startRow);
                const endIndex = rows.indexOf(endRow);

                this.#saveToHistory(pre, true, true); // Force save for multiline tab operations

                for (let i = Math.min(startIndex, endIndex); i <= Math.max(startIndex, endIndex); i++) {
                    const cell = rows[i].cells[1];
                    if (!cell) continue;

                    const text = cell.textContent;
                    if (event.shiftKey) {
                        const dedentedText = text.replace(new RegExp(`^ {1,${this.tabSize}}`), '');
                        cell.textContent = dedentedText;
                    } else {
                        cell.textContent = ' '.repeat(this.tabSize) + text;
                    }
                }

                event.preventDefault();
                return;
            }

            if (event.key === 'Backspace' || event.key === 'Delete') {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                if (range.collapsed) return;

                event.preventDefault();

                const { startContainer, endContainer, startOffset, endOffset } = range;

                const startRow = startContainer.nodeType === 3 ?
                    startContainer.parentNode.closest('tr') :
                    startContainer.closest('tr');
                const endRow = endContainer.nodeType === 3 ?
                    endContainer.parentNode.closest('tr') :
                    endContainer.closest('tr');

                if (!startRow || !endRow) return;

                const table = startRow.closest('table');
                const pre = table.closest('pre');
                const rows = Array.from(table.rows);
                const startIndex = rows.indexOf(startRow);
                const endIndex = rows.indexOf(endRow);

                this.#saveToHistory(pre, true, true); // Force save for multiline delete operations

                const startCell = startRow.cells[1];
                const endCell = endRow.cells[1];

                let startCellTextBefore = '';
                const startTextNodes = this.#getTextNodes(startCell);
                let startNodeIdx = 0;

                while (startNodeIdx < startTextNodes.length) {
                    const node = startTextNodes[startNodeIdx];
                    if (node === startContainer) {
                        startCellTextBefore += node.textContent.substring(0, startOffset);
                        break;
                    } else {
                        startCellTextBefore += node.textContent;
                    }
                    startNodeIdx += 1;
                }

                let endCellTextAfter = '';
                const endTextNodes = this.#getTextNodes(endCell);
                let endNodeIdx = 0;

                while (endNodeIdx < endTextNodes.length) {
                    const node = endTextNodes[endNodeIdx];
                    if (node === endContainer) {
                        endCellTextAfter += node.textContent.substring(endOffset);
                        endNodeIdx += 1;
                        break;
                    }
                    endNodeIdx += 1;
                }

                while (endNodeIdx < endTextNodes.length) {
                    endCellTextAfter += endTextNodes[endNodeIdx].textContent;
                    endNodeIdx += 1;
                }

                if (startIndex === endIndex) {
                    startCell.textContent = startCellTextBefore + endCellTextAfter;
                } else {
                    startCell.textContent = startCellTextBefore + endCellTextAfter;
                    for (let i = endIndex; i > startIndex; i--) {
                        rows[i].remove();
                    }
                    this.#updateLineNumbers(table);
                }

                this.#removeMalformedRows(table);

                if (table.rows.length === 0) {
                    const newRow = document.createElement('tr');
                    newRow.innerHTML = '<td>1</td><td contenteditable="true"></td>';
                    table.appendChild(newRow);
                    this.#updateLineNumbers(table);
                }

                startCell.contentEditable = true;
                startCell.focus();
                this.#setCursorPosition(startCell, startCellTextBefore.length);

                this.activeEditor = null;
                this.multiline = false;

                if (window.hljsl) {
                    window.hljsl.highlight(pre);
                }

                return;
            }

            if (event.key === 'Enter') {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                if (range.collapsed) return;

                event.preventDefault();

                const { startContainer, endContainer } = range;

                const startRow = startContainer.nodeType === 3 ?
                    startContainer.parentNode.closest('tr') :
                    startContainer.closest('tr');
                const endRow = endContainer.nodeType === 3 ?
                    endContainer.parentNode.closest('tr') :
                    endContainer.closest('tr');
                const table = startRow.closest('table');
                const pre = table.closest('pre');

                if (!startRow || !endRow || !table) return;

                this.#saveToHistory(pre, true, true); // Force save for multiline enter operations

                const newRow = document.createElement('tr');
                newRow.innerHTML = '<td></td><td contenteditable="true"></td>';

                const referenceRow = event.shiftKey ? endRow : startRow;
                const indentMatch = referenceRow.cells[1].textContent.match(/^\s*/);
                const indent = indentMatch ? indentMatch[0] : '';
                newRow.cells[1].textContent = indent;

                if (event.shiftKey) {
                    endRow.insertAdjacentElement('afterend', newRow);
                } else {
                    startRow.insertAdjacentElement('beforebegin', newRow);
                }

                this.lastInsertedRow = newRow;
                this.#updateLineNumbers(table);

                return;
            }

            if (event.key === 'Escape' && this.lastInsertedRow) {
                event.preventDefault();

                const cell = this.lastInsertedRow.cells[1];
                cell.focus();

                const { textContent } = cell;
                const indentLength = textContent.match(/^\s*/)[0].length;

                const textNode = cell.firstChild;
                if (textNode && textNode.nodeType === 3) {
                    const newRange = document.createRange();
                    newRange.setStart(textNode, indentLength);
                    newRange.collapse(true);

                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                } else {
                    const newTextNode = document.createTextNode(textContent || '');
                    cell.innerHTML = '';
                    cell.appendChild(newTextNode);

                    const newRange = document.createRange();
                    newRange.setStart(newTextNode, indentLength);
                    newRange.collapse(true);

                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }

                this.lastInsertedRow = null;
                return;
            }

            // Handle regular typing - delete selection and insert typed character
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                event.preventDefault();

                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                if (range.collapsed) return;

                const { startContainer, endContainer, startOffset, endOffset } = range;

                const startRow = startContainer.nodeType === 3 ?
                    startContainer.parentNode.closest('tr') :
                    startContainer.closest('tr');
                const endRow = endContainer.nodeType === 3 ?
                    endContainer.parentNode.closest('tr') :
                    endContainer.closest('tr');

                if (!startRow || !endRow) return;

                const table = startRow.closest('table');
                const pre = table.closest('pre');
                const rows = Array.from(table.rows);
                const startIndex = rows.indexOf(startRow);
                const endIndex = rows.indexOf(endRow);

                this.#saveToHistory(pre, true, true); // Force save for multiline typing operations

                const startCell = startRow.cells[1];
                const endCell = endRow.cells[1];

                let startCellTextBefore = '';
                const startTextNodes = this.#getTextNodes(startCell);
                let startNodeIdx = 0;

                while (startNodeIdx < startTextNodes.length) {
                    const node = startTextNodes[startNodeIdx];
                    if (node === startContainer) {
                        startCellTextBefore += node.textContent.substring(0, startOffset);
                        break;
                    } else {
                        startCellTextBefore += node.textContent;
                    }
                    startNodeIdx += 1;
                }

                let endCellTextAfter = '';
                const endTextNodes = this.#getTextNodes(endCell);
                let endNodeIdx = 0;

                while (endNodeIdx < endTextNodes.length) {
                    const node = endTextNodes[endNodeIdx];
                    if (node === endContainer) {
                        endCellTextAfter += node.textContent.substring(endOffset);
                        endNodeIdx += 1;
                        break;
                    }
                    endNodeIdx += 1;
                }

                while (endNodeIdx < endTextNodes.length) {
                    endCellTextAfter += endTextNodes[endNodeIdx].textContent;
                    endNodeIdx += 1;
                }

                // Delete selection and insert typed character
                if (startIndex === endIndex) {
                    startCell.textContent = startCellTextBefore + event.key + endCellTextAfter;
                } else {
                    startCell.textContent = startCellTextBefore + event.key + endCellTextAfter;
                    for (let i = endIndex; i > startIndex; i--) {
                        rows[i].remove();
                    }
                    this.#updateLineNumbers(table);
                }

                this.#removeMalformedRows(table);

                if (table.rows.length === 0) {
                    const newRow = document.createElement('tr');
                    newRow.innerHTML = '<td>1</td><td contenteditable="true"></td>';
                    table.appendChild(newRow);
                    this.#updateLineNumbers(table);
                }

                startCell.contentEditable = true;
                startCell.focus();
                this.#setCursorPosition(startCell, startCellTextBefore.length + 1);

                // Don't exit multiline mode immediately - let user continue typing
                // Set a flag to indicate we're in typing mode after selection deletion
                this.typingAfterSelection = true;

                // Exit multiline mode after a short delay if no more typing occurs
                setTimeout(() => {
                    if (this.typingAfterSelection) {
                        this.activeEditor = null;
                        this.multiline = false;
                        this.typingAfterSelection = false;
                    }
                }, 100);

                if (window.hljsl) {
                    window.hljsl.highlight(pre);
                }

                return;
            }
        }

        /**
         * Set cursor offset in a node
         * @param {Node} node - The text node
         * @param {number} offset - The offset position
         */
        #setCursorOffset(node, offset) {
            const range = document.createRange();
            range.setStart(node, Math.min(offset, node.length));
            range.setEnd(node, Math.min(offset, node.length));
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }

        /**
         * Get the last text node in an element
         * @param {HTMLElement} element - The element to search
         * @returns {Node|null} The last text node
         */
        #getLastTextNode(element) {
            const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
            let last = null;
            let node;
            while (node = walker.nextNode()) {
                last = node;
            }
            return last;
        }

        /**
         * Get all text nodes in an element
         * @param {HTMLElement} element - The element to search
         * @returns {Node[]} Array of text nodes
         */
        #getTextNodes(element) {
            const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
            const nodes = [];
            let node;
            while (node = walker.nextNode()) {
                nodes.push(node);
            }
            return nodes;
        }

        /**
         * Focus a cell at a specific position
         * @param {HTMLElement} cell - The cell to focus
         * @param {number} pos - The position to focus at
         */
        #focusCell(cell, pos) {
            cell.focus();
            const range = document.createRange();
            const sel = window.getSelection();
            const walker = document.createTreeWalker(cell, NodeFilter.SHOW_TEXT);
            const textNode = walker.nextNode() || cell;
            range.setStart(textNode, Math.min(pos, textNode.length));
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
        }

        /**
         * Update line numbers in a table
         * @param {HTMLElement} table - The table element
         */
        #updateLineNumbers(table) {
            Array.from(table.rows).forEach((row, idx) => {
                const lineNumCell = row.cells[0];
                if (lineNumCell) lineNumCell.textContent = idx + 1;
            });
        }

        /**
         * Remove malformed rows from table
         * @param {HTMLElement} table - The table element
         */
        #removeMalformedRows(table) {
            if (!table) return;
            const malformedRows = Array.from(table.rows).filter((row) => row.cells.length !== 2);
            for (const row of malformedRows) {
                row.remove();
            }
        }

        /**
         * Handle mouse down events
         * @param {MouseEvent} event - The mouse event
         */
        #handleMouseDown(event) {
            // Exit typing mode if clicking
            if (this.typingAfterSelection) {
                this.typingAfterSelection = false;
                this.activeEditor = null;
                this.multiline = false;
            }

            this.activeEditor = event.currentTarget.closest('pre');
            this.multiline = false;

            const selection = window.getSelection();
            if (selection) {
                selection.removeAllRanges();
            }

            const table = event.currentTarget;
            this.#removeMalformedRows(table);
            for (const row of table.rows) {
                row.cells[1].contentEditable = false;
            }
        }

        /**
         * Handle mouse up events
         * @param {MouseEvent} event - The mouse event
         */
        #handleMouseUp(event) {
            const table = event.currentTarget || event.target;
            const selection = window.getSelection();
            const selectedText = selection.toString();

            if (selectedText.includes('\n')) {
                const pre = table.closest('pre');
                this.activeEditor = pre;
                this.multiline = true;

                const operationId = `multiline-selection-${Date.now()}`;
                this.addPendingOperation(operationId);
                setTimeout(() => {
                    this.removePendingOperation(operationId);
                }, 500);

                return;
            }

            if (selectedText && !selectedText.includes('\n')) {
                this.activeEditor = null;
                this.multiline = false;

                const operationId = `single-selection-${Date.now()}`;
                this.addPendingOperation(operationId);

                const handleSelectionKeydown = (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' ||
                        e.key === 'ArrowUp' || e.key === 'ArrowDown' ||
                        e.key === 'Home' || e.key === 'End') {
                        e.preventDefault();

                        const td = event.target.closest('td');
                        if (!td) {
                            document.removeEventListener('keydown', handleSelectionKeydown, true);
                            this.removePendingOperation(operationId);
                            return;
                        }

                        td.contentEditable = true;
                        td.focus();

                        if (e.key === 'Home' || e.key === 'End') {
                            const textNodes = this.#getTextNodes(td);

                            if (textNodes.length > 0) {
                                try {
                                    const range = document.createRange();

                                    if (e.key === 'Home') {
                                        range.setStart(textNodes[0], 0);
                                    } else {
                                        const lastNode = textNodes[textNodes.length - 1];
                                        range.setStart(lastNode, lastNode.textContent.length);
                                    }

                                    range.collapse(true);

                                    const selection = window.getSelection();
                                    selection.removeAllRanges();
                                    selection.addRange(range);
                                } catch (err) {
                                    console.error('Error positioning cursor:', err);
                                }
                            }

                            document.removeEventListener('keydown', handleSelectionKeydown, true);
                            this.removePendingOperation(operationId);
                            return;
                        }

                        setTimeout(() => {
                            const fullText = td.textContent;
                            const pos = fullText.indexOf(selectedText);

                            if (pos !== -1) {
                                const textNodes = Array.from(td.childNodes).filter(
                                    (node) => node.nodeType === 3 || node.nodeName === 'SPAN'
                                );

                                let currentPos = 0;
                                let targetNode = null;
                                let targetOffset = 0;

                                for (const node of textNodes) {
                                    const nodeLength = node.textContent.length;

                                    if (e.key === 'ArrowLeft' && currentPos <= pos && pos < currentPos + nodeLength) {
                                        targetNode = node.nodeType === 3 ? node : node.firstChild;
                                        targetOffset = pos - currentPos;
                                        break;
                                    } else if (e.key !== 'ArrowLeft' &&
                                              currentPos <= (pos + selectedText.length) &&
                                              (pos + selectedText.length) <= currentPos + nodeLength) {
                                        targetNode = node.nodeType === 3 ? node : node.firstChild;
                                        targetOffset = (pos + selectedText.length) - currentPos;
                                        break;
                                    }

                                    currentPos += nodeLength;
                                }

                                if (targetNode) {
                                    try {
                                        const range = document.createRange();
                                        range.setStart(targetNode, targetOffset);
                                        range.collapse(true);

                                        const selection = window.getSelection();
                                        selection.removeAllRanges();
                                        selection.addRange(range);
                                    } catch (e) {
                                        console.error('Error positioning cursor:', e);
                                    }
                                }
                            }

                            document.removeEventListener('keydown', handleSelectionKeydown, true);
                            this.removePendingOperation(operationId);
                        }, 10);
                    } else if (e.key === 'Backspace' || e.key === 'Delete') {
                        e.preventDefault();

                        const td = event.target.closest('td');
                        if (!td) {
                            document.removeEventListener('keydown', handleSelectionKeydown, true);
                            this.removePendingOperation(operationId);
                            return;
                        }

                        td.contentEditable = true;
                        td.focus();

                        const fullText = td.textContent;
                        const pos = fullText.indexOf(selectedText);

                        if (pos !== -1) {
                            const newText = fullText.substring(0, pos) +
                                           fullText.substring(pos + selectedText.length);

                            td.textContent = newText;

                            const textNode = td.firstChild;
                            if (textNode && textNode.nodeType === 3) {
                                const range = document.createRange();
                                range.setStart(textNode, pos);
                                range.collapse(true);
                                const selection = window.getSelection();
                                selection.removeAllRanges();
                                selection.addRange(range);
                            } else {
                                const emptyNode = document.createTextNode('');
                                td.appendChild(emptyNode);

                                const range = document.createRange();
                                range.setStart(emptyNode, 0);
                                range.collapse(true);
                                const selection = window.getSelection();
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }

                        } else {
                            td.focus();
                            const textNode = this.#getTextNodes(td)[0];
                            if (textNode) {
                                const range = document.createRange();
                                range.setStart(textNode, 0);
                                range.collapse(true);
                                const selection = window.getSelection();
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }
                        }

                        document.removeEventListener('keydown', handleSelectionKeydown, true);
                        this.removePendingOperation(operationId);
                    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                        // Handle typing to replace selection
                        e.preventDefault();

                        const td = event.target.closest('td');
                        if (!td) {
                            document.removeEventListener('keydown', handleSelectionKeydown, true);
                            this.removePendingOperation(operationId);
                            return;
                        }

                        td.contentEditable = true;
                        td.focus();

                        const fullText = td.textContent;
                        const pos = fullText.indexOf(selectedText);

                        if (pos !== -1) {
                            const newText = fullText.substring(0, pos) + e.key +
                                           fullText.substring(pos + selectedText.length);

                            td.textContent = newText;

                            const textNode = td.firstChild;
                            if (textNode && textNode.nodeType === 3) {
                                const range = document.createRange();
                                range.setStart(textNode, pos + 1);
                                range.collapse(true);
                                const selection = window.getSelection();
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }
                        }

                        document.removeEventListener('keydown', handleSelectionKeydown, true);
                        this.removePendingOperation(operationId);
                    } else if (e.key !== 'Shift' && e.key !== 'Alt' &&
                             e.key !== 'Control' && e.key !== 'Meta') {
                        document.removeEventListener('keydown', handleSelectionKeydown, true);
                        this.removePendingOperation(operationId);
                    }
                };

                document.addEventListener('keydown', handleSelectionKeydown, true);

                setTimeout(() => {
                    this.removePendingOperation(operationId);
                }, 5000);

                return;
            }

            if (!selection || selection.isCollapsed) {
                this.activeEditor = null;
                this.multiline = false;

                const row = event.target.closest('tr');
                if (row) {
                    const cell = row.cells[1];
                    if (cell) {
                        cell.contentEditable = true;
                        cell.focus();
                    }
                }
            }

            for (const row of table.rows) {
                const cell = row.cells[1];
                if (cell) cell.contentEditable = true;
            }
        }

        /**
         * Deactivate an editor instance
         * @param {HTMLElement} pre - The pre element
         */
        deactivateEditor(pre) {
            const table = pre.querySelector('table');
            if (!table) {
                return;
            }

            const editorId = pre.dataset.hljslId;
            this.cursorX = this.#getCursorPosition(pre);

            const controls = pre.previousElementSibling;
            if (controls && controls.classList.contains('editor-controls')) {
                pre.classList.add('disabled');
            }

            if (pre._debounceHandler) {
                table.removeEventListener('keyup', pre._debounceHandler);

                const timerId = this.debounceTimers.get(pre);
                if (timerId) {
                    clearTimeout(timerId);
                    this.debounceTimers.delete(pre);
                }

                delete pre._debounceHandler;
            }

            table.removeEventListener('keydown', this.#handleKeyDown.bind(this));
            table.removeEventListener('mousedown', this.#handleMouseDown.bind(this));
            table.removeEventListener('paste', this.#handlePastedContent.bind(this));
            table.removeEventListener('mouseup', this.#handleMouseUp.bind(this));

            for (const row of table.rows) {
                const codeCell = row.cells[1];
                if (codeCell) codeCell.contentEditable = false;
            }

            if (editorId) {
                const historyTimer = this.historyTimers.get(editorId);
                if (historyTimer) {
                    clearTimeout(historyTimer);
                    this.historyTimers.delete(editorId);
                }
            }

            this.editors.delete(pre);
        }

        /**
         * Create unique identifier
         * @returns {string} Unique ID
         */
        createId() {
            return `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`.toUpperCase();
        }

        /**
         * Update editor with highlighting
         * @param {HTMLElement} pre - The pre element to update
         */
        updateEditor(pre) {
            if (!window.hljsl) {
                return;
            }

            if (this.suppressHighlighting || this.pendingOperations.size > 0) {
                return;
            }

            const { activeElement } = document;
            const isInPre = pre.contains(activeElement);

            if (isInPre && activeElement.tagName === 'TD') {
                const selection = window.getSelection();
                const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;

                if (range) {
                    const cell = activeElement;
                    const row = cell.closest('tr');
                    const table = row.closest('table');
                    const rowIndex = Array.from(table.rows).indexOf(row);
                    const colIndex = Array.from(row.cells).indexOf(cell);
                    const cursorPosition = this.#getCursorPosition(cell, range);

                    const observer = new MutationObserver((mutations, obs) => {
                        obs.disconnect();

                        const updatedTable = pre.querySelector('table');
                        if (updatedTable && rowIndex >= 0 && rowIndex < updatedTable.rows.length) {
                            const updatedRow = updatedTable.rows[rowIndex];
                            if (updatedRow && colIndex >= 0 && colIndex < updatedRow.cells.length) {
                                const updatedCell = updatedRow.cells[colIndex];

                                updatedCell.contentEditable = true;
                                updatedCell.focus();

                                this.#setCursorPosition(updatedCell, cursorPosition);
                            }
                        }
                    });

                    observer.observe(pre, {
                        childList: true,
                        subtree: true,
                        characterData: true,
                        attributes: true
                    });

                    window.hljsl.highlight(pre);
                } else {
                    window.hljsl.highlight(pre);
                }
            } else {
                window.hljsl.highlight(pre);
            }
        }

    }

    /**
     * @class DOMWatcher
     * @description A utility class to observe and react to dynamic DOM changes using a MutationObserver.
     * This class allows you to watch for specific elements based on a selector, and call a callback
     * when those elements are added to the DOM, including any existing matching elements at the time
     * of the observation.
     */
    class DOMWatcher {

        constructor() {
            this.watchersBySelector = new Map();
            this.observedElements = new WeakSet(); // Track elements we've already processed
            this.observer = new MutationObserver(this.handleMutations.bind(this));
            this.observer.observe(document.documentElement, {
                childList: true,
                subtree: true
            });
        }

        handleMutations(mutations) {
            // Process all added nodes in a single batch
            const addedNodes = new Set();
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === 1) addedNodes.add(node);
                });
            });

            // Check each node against selectors
            addedNodes.forEach(this.checkNode.bind(this));
        }

        watch(selector, callback, once = true) {
            const watchId = Symbol();
            if (!this.watchersBySelector.has(selector)) {
                this.watchersBySelector.set(selector, new Map());
            }

            const wrappedCallback = (element) => {
                // Skip if we've already processed this element
                if (this.observedElements.has(element)) {
                    return;
                }

                // Mark as processed
                this.observedElements.add(element);

                // Call the callback
                callback(element);

                if (once) {
                    this.unwatch(selector, watchId);
                }
            };

            this.watchersBySelector.get(selector).set(watchId, wrappedCallback);

            // Check existing elements
            const existingElement = document.querySelector(selector);
            if (existingElement) {
                wrappedCallback(existingElement);
            }

            return {
                unwatch: () => this.unwatch(selector, watchId)
            };
        }

        unwatch(selector, id) {
            const callbacks = this.watchersBySelector.get(selector);
            if (callbacks) {
                callbacks.delete(id);
                if (callbacks.size === 0) {
                    this.watchersBySelector.delete(selector);
                }
            }
        }

        checkNode(node) {
            if (!node.matches) return;

            this.watchersBySelector.forEach((callbacks, selector) => {
                // Check if the node itself matches
                if (node.matches(selector)) {
                    callbacks.forEach((callback) => callback(node));
                } else {
                    // If parent doesn't match, check for first matching child
                    const matchingChild = node.querySelector(selector);
                    if (matchingChild) {
                        callbacks.forEach((callback) => callback(matchingChild));
                    }
                }
            });
        }

        disconnect() {
            this.observer.disconnect();
            this.watchersBySelector.clear();
        }

    }

    /**
     * Fast programming language detection class
     * Optimized for speed with smart sampling and early termination
     */
    class LanguageDetector {

        /** @type {string[]} Default fallback languages */
        #defaultLanguages = ['javascript', 'python', 'java', 'html', 'css', 'cpp', 'go', 'rust', 'typescript', 'php'];

        /** @type {Object} Pre-compiled regex patterns organized by detection strength */
        #patterns = {
            // Definitive patterns - if found, we're very confident
            definitive: [
                // Template languages - must be first to avoid HTML confusion
                { regex: /\{%[\s\S]*?%\}/, langs: ['django'], weight: 50 },
                { regex: /\{%\s*(if|for|block|extends|include|load|endif|endfor|endblock)/, langs: ['django'], weight: 50 },
                { regex: /\{\{\s*\w+\s*\|\s*\w+/, langs: ['django'], weight: 45 },
                { regex: /\{\{[\s\S]*?\}\}/, langs: ['handlebars'], weight: 45 },
                { regex: /<%[\s\S]*?%>/, langs: ['erb'], weight: 45 },

                // Web languages
                { regex: /^\s*<\?php/i, langs: ['php'], weight: 50 },
                { regex: /^\s*<!doctype\s+html/i, langs: ['html'], weight: 50 },
                { regex: /^\s*<html[^>]*>/i, langs: ['html'], weight: 45 },
                { regex: /^\s*<\?xml/i, langs: ['xml'], weight: 45 },

                // System languages with very specific patterns
                { regex: /^#include\s*<iostream>/m, langs: ['cpp'], weight: 50 },
                { regex: /^#include\s*<stdio\.h>/m, langs: ['c'], weight: 50 },
                { regex: /using\s+namespace\s+std/, langs: ['cpp'], weight: 45 },
                { regex: /std::vector|std::string|std::cout/, langs: ['cpp'], weight: 40 },

                // Package/Module declarations
                { regex: /^\s*package\s+main\b/m, langs: ['go'], weight: 50 },
                { regex: /fn\s+main\s*\(\s*\)/, langs: ['rust'], weight: 50 },
                { regex: /public\s+static\s+void\s+main\s*\(\s*String\[\]/i, langs: ['java'], weight: 50 },
                { regex: /^\s*package\s+[\w.]+\s*;/m, langs: ['java'], weight: 35 },

                // Scripting languages with shebangs
                { regex: /^#!/, langs: ['bash', 'python', 'perl', 'ruby'], weight: 35 },
                { regex: /^#!\/bin\/bash/i, langs: ['bash'], weight: 50 },
                { regex: /^#!\/usr\/bin\/bash/i, langs: ['bash'], weight: 50 },
                { regex: /^#!\/usr\/bin\/env\s+python/i, langs: ['python'], weight: 50 },
                { regex: /^#!\/usr\/bin\/env\s+ruby/i, langs: ['ruby'], weight: 50 },
                { regex: /^#!\/usr\/bin\/env\s+perl/i, langs: ['perl'], weight: 50 },

                // Very distinctive language patterns
                { regex: /-module\s*\(\s*\w+\s*\)/, langs: ['erlang'], weight: 50 },
                { regex: /-behaviour\s*\(/, langs: ['erlang'], weight: 45 },
                { regex: /defmodule\s+\w+/, langs: ['elixir'], weight: 50 },
                { regex: /defrecord\s+\w+/, langs: ['elixir'], weight: 45 },
                { regex: /library\s+\w+;/, langs: ['dart'], weight: 50 },
                { regex: /import\s+['"]dart:/, langs: ['dart'], weight: 45 },

                // Config/Build files with unique patterns
                { regex: /cmake_minimum_required\s*\(/i, langs: ['cmake'], weight: 50 },
                { regex: /^FROM\s+[\w\/.:-]+/mi, langs: ['dockerfile'], weight: 50 },
                { regex: /^# Example instructions from https:\/\/docs\.docker\.com\/reference\/builder/mi, langs: ['dockerfile'], weight: 45 },
                { regex: /LoadModule\s+\w+/i, langs: ['apache'], weight: 50 },
                { regex: /^\s*server\s*\{/m, langs: ['nginx'], weight: 50 },

                // Database languages
                { regex: /^\s*(select|SELECT)\s+[\w\*,\s]+\s+(from|FROM)\s+\w+/m, langs: ['sql'], weight: 45 },

                // Functional languages
                { regex: /^\s*module\s+\w+\s+where/mi, langs: ['haskell'], weight: 50 },
                { regex: /^\s*open\s+System/mi, langs: ['fsharp'], weight: 45 },
                { regex: /type\s+\w+\s*=\s*\|/, langs: ['fsharp'], weight: 40 },

                // Assembly languages
                { regex: /^\s*section\s+\./mi, langs: ['x86asm'], weight: 50 },
                { regex: /mov\s+e[a-z]{2},\s*\w+/gi, langs: ['x86asm'], weight: 45 },

                // LaTeX/TeX
                { regex: /\\documentclass\s*\{/i, langs: ['latex'], weight: 50 },
                { regex: /\\begin\s*\{document\}/i, langs: ['latex'], weight: 50 },
                { regex: /\\usepackage\s*\{/i, langs: ['latex'], weight: 40 },

                // MATLAB/Octave
                { regex: /^\s*function\s+[\w,\[\]]+\s*=\s*\w+\s*\(/mi, langs: ['matlab'], weight: 50 },
                { regex: /%%\s/, langs: ['matlab'], weight: 40 },

                // Version control - higher priority for diff detection
                { regex: /^diff\s+--git/m, langs: ['diff'], weight: 50 },
                { regex: /^Index:\s+[\w\/\.]+/m, langs: ['diff'], weight: 50 },
                { regex: /^@@\s+-\d+,\d+\s+\+\d+,\d+\s+@@/m, langs: ['diff'], weight: 50 },
                { regex: /^---\s+[\w\/\.]+/m, langs: ['diff'], weight: 45 },
                { regex: /^\+{3}\s+[\w\/\.]+/m, langs: ['diff'], weight: 45 },

                // Lisp family - order matters for specificity
                { regex: /^\s*\(ns\s+\w+/m, langs: ['clojure'], weight: 50 },
                { regex: /\(defmacro\s+\w+/, langs: ['clojure'], weight: 45 },
                { regex: /\(defprotocol\s+\w+/, langs: ['clojure'], weight: 45 },
                { regex: /\(def\s+\w+[\s\[]/, langs: ['clojure'], weight: 35 },
                { regex: /\(define\s+\w+/, langs: ['scheme'], weight: 45 },
                { regex: /\(lambda\s*\(/, langs: ['scheme'], weight: 40 },
                { regex: /\(defun\s+\w+/, langs: ['lisp'], weight: 45 },

                // Pascal/Delphi distinction
                { regex: /^\s*unit\s+\w+\s*;/mi, langs: ['delphi'], weight: 50 },
                { regex: /^\s*program\s+\w+\s*;/mi, langs: ['pascal'], weight: 50 },
                { regex: /\bClass\s*\(/gi, langs: ['delphi'], weight: 40 },

                // Fortran
                { regex: /^\s*subroutine\s+\w+/mi, langs: ['fortran'], weight: 50 },
                { regex: /^\s*implicit\s+none/mi, langs: ['fortran'], weight: 45 },
                { regex: /^\s*program\s+\w+/mi, langs: ['fortran'], weight: 40 },

                // OCaml
                { regex: /^\s*type\s+\w+\s*=\s*[\|\{]/m, langs: ['ocaml'], weight: 45 },
                { regex: /\|\s*\w+\s*->/, langs: ['ocaml'], weight: 40 },
                { regex: /match\s+\w+\s+with/, langs: ['ocaml'], weight: 40 },

                // TypeScript specific patterns
                { regex: /interface\s+\w+\s*\{/, langs: ['typescript'], weight: 45 },
                { regex: /:\s*(string|number|boolean|any)\s*[=\;\,\)]/g, langs: ['typescript'], weight: 40 },
                { regex: /public\s+\w+\s*:\s*(string|number|boolean)/, langs: ['typescript'], weight: 45 },

                // ActionScript specific
                { regex: /^\s*package\s+[\w.]+\s*\{/m, langs: ['actionscript'], weight: 50 },
                { regex: /:\s*(Array|uint|int|String|Boolean|Number|void)\s*[=\{\(]/, langs: ['actionscript'], weight: 40 },

                // VB.NET vs VBScript
                { regex: /^\s*Imports?\s+System/mi, langs: ['vbnet'], weight: 50 },
                { regex: /^\s*Public\s+Class\s+\w+/mi, langs: ['vbnet'], weight: 45 },
                { regex: /^\s*Namespace\s+\w+/mi, langs: ['vbnet'], weight: 45 },
                { regex: /Set\s+\w+\s*=\s*CreateObject/gi, langs: ['vbscript'], weight: 45 },

                // Prolog
                { regex: /^\s*\w+\s*\([^)]*\)\s*:-/m, langs: ['prolog'], weight: 50 },
                { regex: /:-\s*\w+\s*\(/, langs: ['prolog'], weight: 40 },

                // Smalltalk
                { regex: /^\s*\w+>>\w+:/m, langs: ['smalltalk'], weight: 50 },
                { regex: /\|\s*\w+\s*\w+\s*\|/, langs: ['smalltalk'], weight: 40 },

                // TCL
                { regex: /^\s*proc\s+\w+\s*\{/m, langs: ['tcl'], weight: 50 },
                { regex: /\$\w+\s+\{/, langs: ['tcl'], weight: 35 },

                // Makefile - improved detection
                { regex: /^\w+:\s*$/m, langs: ['makefile'], weight: 45 },
                { regex: /^\t[\w\$]/, langs: ['makefile'], weight: 40 },
                { regex: /^\.PHONY:/m, langs: ['makefile'], weight: 45 },

                // Lua - improved detection
                { regex: /--\[\[[\s\S]*?\]\]/, langs: ['lua'], weight: 45 },
                { regex: /local\s+function\s+\w+/, langs: ['lua'], weight: 40 },
                { regex: /function\s+\w+\s*\([^)]*\)/, langs: ['lua'], weight: 35 },

                // PHP - better detection without <?php
                { regex: /namespace\s+[\w\\]+\s*;/, langs: ['php'], weight: 40 },
                { regex: /use\s+[\w\\]+\s*;/, langs: ['php'], weight: 35 },
                { regex: /require_once\s+/, langs: ['php'], weight: 35 },

                // CSS preprocessors - better distinction
                { regex: /@import\s+['"][^'"]*\.less['"]/, langs: ['less'], weight: 45 },
                { regex: /\.\w+\s*\{\s*\.\w+/, langs: ['less'], weight: 40 },
                { regex: /@\w+\s*:\s*[^;]+;/, langs: ['less'], weight: 35 }

            ],

            // Very strong indicators
            strong: [
                // Language-specific built-ins and distinctive function calls
                { regex: /console\.log\s*\(/, langs: ['javascript'], weight: 25 },
                { regex: /System\.out\.println\s*\(/, langs: ['java'], weight: 30 },
                { regex: /fmt\.Printf?\s*\(/, langs: ['go'], weight: 25 },
                { regex: /println!\s*\(/, langs: ['rust'], weight: 25 },
                { regex: /print\s*\(/, langs: ['python'], weight: 15 },
                { regex: /puts\s+/, langs: ['ruby'], weight: 20 },
                { regex: /echo\s+/, langs: ['php', 'bash'], weight: 10 },
                { regex: /printf\s*\(/, langs: ['c', 'cpp'], weight: 15 },
                { regex: /disp\s*\(/, langs: ['matlab'], weight: 20 },

                // Function definitions by language
                { regex: /def\s+\w+\s*\(/, langs: ['python', 'ruby'], weight: 20 },
                { regex: /function\s+\w+\s*\(/, langs: ['javascript', 'php'], weight: 15 },
                { regex: /fn\s+\w+\s*\(/, langs: ['rust'], weight: 20 },
                { regex: /func\s+\w+\s*\(/, langs: ['go', 'swift'], weight: 18 },
                { regex: /fun\s+\w+\s*\(/, langs: ['kotlin'], weight: 20 },
                { regex: /sub\s+\w+/, langs: ['perl'], weight: 18 },
                { regex: /procedure\s+\w+/gi, langs: ['pascal', 'delphi'], weight: 20 },
                { regex: /defun\s+\w+/, langs: ['lisp'], weight: 25 },
                { regex: /define\s+\w+/, langs: ['scheme'], weight: 20 },
                { regex: /defp?\s+\w+/, langs: ['elixir'], weight: 25 },

                // Import/Include patterns
                { regex: /^from\s+\w+\s+import/m, langs: ['python'], weight: 20 },
                { regex: /^import\s+\w+/m, langs: ['python', 'java', 'go', 'swift'], weight: 12 },
                { regex: /require\s*\(/, langs: ['javascript'], weight: 15 },
                { regex: /require\s+['"][^'"]+['"]/, langs: ['ruby'], weight: 15 },
                { regex: /use\s+\w+::/, langs: ['rust'], weight: 18 },
                { regex: /use\s+\w+/, langs: ['rust', 'php'], weight: 10 },
                { regex: /#include\s*[<"]/, langs: ['c', 'cpp'], weight: 15 },
                { regex: /using\s+namespace/, langs: ['cpp'], weight: 18 },
                { regex: /using\s+System/, langs: ['csharp'], weight: 18 },

                // Language-specific operators and syntax
                { regex: /std::cout\s*<</, langs: ['cpp'], weight: 20 },
                { regex: /cout\s*<</, langs: ['cpp'], weight: 15 },
                { regex: /::\w+/, langs: ['cpp', 'rust', 'scala'], weight: 12 },
                { regex: /=>\s*/, langs: ['javascript', 'rust', 'csharp', 'scala'], weight: 8 },
                { regex: /\$\w+/, langs: ['php', 'bash', 'perl'], weight: 12 },
                { regex: /@\w+/, langs: ['java', 'csharp', 'python'], weight: 8 },
                { regex: /\|>/, langs: ['elixir', 'fsharp'], weight: 15 },
                { regex: /<-/, langs: ['r', 'haskell'], weight: 15 },
                { regex: /\?\?/, langs: ['csharp'], weight: 15 },
                { regex: /\.\./, langs: ['rust', 'perl'], weight: 10 },

                // CoffeeScript distinctive patterns
                { regex: /\w+\s*:\s*\([^)]*\)\s*->/, langs: ['coffeescript'], weight: 25 },
                { regex: /\w+\s*=\s*->/, langs: ['coffeescript'], weight: 20 },
                { regex: /#{[^}]+}/, langs: ['coffeescript'], weight: 20 },
                { regex: /"""\s*[\s\S]*?"""/, langs: ['coffeescript'], weight: 15 },
                { regex: /@\w+/, langs: ['coffeescript'], weight: 20 },
                { regex: /\?\s*\./, langs: ['coffeescript'], weight: 18 },

                // Bash specific patterns
                { regex: /\[\[\s+.*\s+\]\]/, langs: ['bash'], weight: 25 },
                { regex: /\$\([^)]+\)/, langs: ['bash'], weight: 20 },
                { regex: /\${[^}]+}/, langs: ['bash'], weight: 18 },
                { regex: /if\s+\[\s+.*\s+\]/, langs: ['bash'], weight: 20 },
                { regex: /for\s+\w+\s+in\s+.*do/gi, langs: ['bash'], weight: 18 },

                // Dart specific patterns
                { regex: /part\s+['"][^'"]+['"]/, langs: ['dart'], weight: 25 },
                { regex: /part\s+of\s+\w+/, langs: ['dart'], weight: 25 },
                { regex: /factory\s+\w+/, langs: ['dart'], weight: 20 },

                // Elixir specific patterns
                { regex: /\|>\s*\w+/, langs: ['elixir'], weight: 25 },
                { regex: /do\s*$/m, langs: ['elixir'], weight: 15 },
                { regex: /end$/m, langs: ['elixir', 'ruby'], weight: 12 },

                // Ruby specific patterns - improved
                { regex: /\.each\s+do\s*\|/, langs: ['ruby'], weight: 25 },
                { regex: /def\s+self\./, langs: ['ruby'], weight: 25 },
                { regex: /class\s+\w+\s*<\s*\w+/, langs: ['ruby'], weight: 20 },
                { regex: /end\s*$/, langs: ['ruby', 'elixir'], weight: 15 },

                // More language-specific patterns for better accuracy
                { regex: /library\s*\(/, langs: ['r'], weight: 25 },
                { regex: /data\.frame\s*\(/, langs: ['r'], weight: 20 },

                // Config file patterns
                { regex: /RewriteCond\s+/, langs: ['apache'], weight: 18 },
                { regex: /location\s+[^{]+\s*\{/, langs: ['nginx'], weight: 20 },
                { regex: /proxy_pass\s+/, langs: ['nginx'], weight: 18 },
                { regex: /^\s*\[\w+\]/m, langs: ['ini'], weight: 15 }
            ],

            // Medium strength indicators
            medium: [
                // Class and type definitions
                { regex: /\bclass\s+\w+\s*\{/, langs: ['java', 'cpp', 'csharp', 'javascript', 'actionscript'], weight: 8 },
                { regex: /\bclass\s+\w+\s*:/, langs: ['python'], weight: 12 },
                { regex: /\bclass\s+\w+\s*extends/, langs: ['java', 'javascript', 'actionscript'], weight: 10 },
                { regex: /\bstruct\s+\w+/, langs: ['c', 'cpp', 'rust', 'go'], weight: 10 },
                { regex: /\benum\s+\w+/, langs: ['java', 'cpp', 'csharp', 'rust', 'swift'], weight: 8 },
                { regex: /\binterface\s+\w+/, langs: ['java', 'csharp', 'typescript', 'go', 'actionscript'], weight: 10 },
                { regex: /\btrait\s+\w+/, langs: ['scala', 'rust'], weight: 12 },
                { regex: /\btype\s+\w+/, langs: ['haskell', 'scala'], weight: 8 },

                // Variable declarations
                { regex: /\blet\s+\w+/, langs: ['javascript', 'rust', 'swift', 'typescript'], weight: 6 },
                { regex: /\bvar\s+\w+\s*:/, langs: ['actionscript', 'swift', 'typescript'], weight: 8 },
                { regex: /\bvar\s+\w+/, langs: ['javascript', 'csharp', 'go', 'swift'], weight: 5 },
                { regex: /\bconst\s+\w+/, langs: ['javascript', 'cpp', 'rust', 'typescript'], weight: 6 },

                // CSS/Styling
                { regex: /@media\s+/, langs: ['css', 'scss', 'less'], weight: 8 },
                { regex: /@import\s+/, langs: ['css', 'scss', 'less'], weight: 6 },
                { regex: /@mixin\s+/, langs: ['scss'], weight: 10 },
                { regex: /@include\s+/, langs: ['scss'], weight: 10 },
                { regex: /\$\w+\s*:/, langs: ['scss'], weight: 8 }
            ],

            // Light indicators
            light: [
                // Comments by language family
                { regex: /\/\//, langs: ['javascript', 'java', 'cpp', 'csharp', 'go', 'rust', 'swift', 'actionscript', 'kotlin', 'scala'], weight: 2 },
                { regex: /\/\*[\s\S]*?\*\//, langs: ['javascript', 'java', 'cpp', 'csharp', 'go', 'rust', 'actionscript', 'kotlin', 'scala'], weight: 3 },
                { regex: /#[^!]/, langs: ['python', 'ruby', 'bash', 'perl', 'cmake', 'yaml'], weight: 2 },
                { regex: /<!--[\s\S]*?-->/, langs: ['html', 'xml'], weight: 5 },
                { regex: /\(\*[\s\S]*?\*\)/, langs: ['pascal', 'delphi', 'ocaml'], weight: 4 },
                { regex: /;[^;]*$/gm, langs: ['lisp', 'scheme'], weight: 3 },
                { regex: /%[^%]*$/gm, langs: ['matlab', 'erlang'], weight: 3 },
                { regex: /--[^-]*$/gm, langs: ['haskell', 'sql'], weight: 3 },
                { regex: /'/, langs: ['vbnet'], weight: 2 },

                // Basic syntax patterns
                { regex: /\{[^}]*\}/, langs: ['javascript', 'java', 'cpp', 'csharp', 'go', 'rust', 'swift', 'actionscript', 'kotlin', 'scala'], weight: 1 },
                { regex: /;$/gm, langs: ['javascript', 'java', 'cpp', 'csharp', 'go', 'rust', 'actionscript', 'kotlin', 'scala'], weight: 1 },
                { regex: /:\s*$/gm, langs: ['python', 'yaml'], weight: 2 },
                { regex: /\bbegin\b/gi, langs: ['pascal', 'delphi', 'ruby'], weight: 2 },
                { regex: /\bend\b/gi, langs: ['pascal', 'delphi', 'ruby'], weight: 2 }
            ],

            // Special patterns for markup, data, and config languages
            special: [
                // Markup languages
                { regex: /<\w+[^>]*>/, langs: ['html', 'xml'], weight: 12 },
                { regex: /<\/\w+>/, langs: ['html', 'xml'], weight: 10 },
                { regex: /<!\[CDATA\[/, langs: ['xml'], weight: 20 },
                { regex: /xmlns:/, langs: ['xml'], weight: 15 },
                { regex: /<\w+:\w+/, langs: ['xml'], weight: 12 },

                // CSS and preprocessors
                { regex: /\.\w+\s*\{[^}]*\}/, langs: ['css', 'scss', 'less'], weight: 15 },
                { regex: /#\w+\s*\{[^}]*\}/, langs: ['css', 'scss', 'less'], weight: 12 },
                { regex: /\w+\s*:\s*[^;]+;/, langs: ['css', 'scss', 'less'], weight: 8 },

                // Database languages
                { regex: /\b(select|from|where|insert|update|delete|create|table|database)\b/i, langs: ['sql', 'pgsql'], weight: 15 },
                { regex: /\b(join|inner|outer|left|right)\s+join\b/i, langs: ['sql', 'pgsql'], weight: 12 },

                // Data formats
                { regex: /^\s*\{[\s\S]*\}$/m, langs: ['json'], weight: 12 },
                { regex: /^\s*\[[\s\S]*\]$/m, langs: ['json'], weight: 12 },
                { regex: /"\w+"\s*:\s*"/, langs: ['json'], weight: 15 },
                { regex: /---\s*$/m, langs: ['yaml'], weight: 15 },

                // Config files
                { regex: /^\s*\[\w+\]\s*$/m, langs: ['ini', 'toml'], weight: 15 },
                { regex: /^\s*\w+\s*=\s*[^=]/m, langs: ['ini', 'properties', 'toml'], weight: 10 },

                // Documentation
                { regex: /^\s*#+\s+/, langs: ['markdown'], weight: 12 },
                { regex: /\[.*?\]\(.*?\)/, langs: ['markdown'], weight: 10 },
                { regex: /```\w*/, langs: ['markdown'], weight: 15 }
            ]
        };

        constructor() {
            // Pre-compile any dynamic optimizations if needed
            this.#optimizePatterns();
        }

        /**
         * Pre-compile and optimize regex patterns for better performance
         * @private
         */
        #optimizePatterns() {
            // Patterns are already optimized, but we could add runtime optimizations here
            // For now, just ensure all patterns are properly structured
        }

        /**
         * Get a strategic sample of code for analysis
         * Takes beginning, middle, and end portions for better detection while maintaining speed
         * @private
         * @param {string} code - The full code to sample
         * @param {number} maxLength - Maximum length of sample to return
         * @returns {string} Strategic sample of the code
         */
        #getSampleText(code, maxLength = 2500) {
            if (code.length <= maxLength) {
                return code;
            }

            // For very large files, take strategic samples
            // Most language indicators are in the first portion, but some are scattered
            const quarterLength = Math.floor(code.length / 4);

            // Take first 1500 chars (most imports, declarations, etc.)
            const start = code.slice(0, 1500);

            // Take 400 chars from around 1/4 position (catch any missed patterns)
            const quarter = code.slice(quarterLength - 200, quarterLength + 200);

            // Take 300 chars from around 1/2 position (catch middle patterns)
            const middle = code.slice(Math.floor(code.length * 0.4), Math.floor(code.length * 0.4) + 300);

            // Take last 300 chars (catch any end patterns)
            const end = code.slice(-300);

            return `${start}\n${quarter}\n${middle}\n${end}`;
        }

        /**
         * Add weighted scores to languages
         * @private
         * @param {Map<string, number>} scores - Score map to update
         * @param {string[]} languages - Languages to add scores to
         * @param {number} weight - Weight to add
         */
        #addScore(scores, languages, weight) {
            for (let i = 0; i < languages.length; i++) {
                const lang = languages[i];
                scores.set(lang, (scores.get(lang) || 0) + weight);
            }
        }

        /**
         * Process a set of patterns against code
         * @private
         * @param {string} code - Code to analyze
         * @param {Object[]} patterns - Patterns to check
         * @param {Map<string, number>} scores - Score map to update
         * @param {number} maxMatches - Maximum matches to count per pattern
         * @param {boolean} earlyExit - Whether to exit early on very strong matches
         * @returns {boolean} True if very strong match found and early exit enabled
         */
        #processPatterns(code, patterns, scores, maxMatches = 10, earlyExit = false) {
            let foundVeryStrong = false;

            for (let i = 0; i < patterns.length; i++) {
                const { regex, langs, weight } = patterns[i];

                // Reset regex lastIndex to ensure consistent behavior
                if (regex.global) {
                    regex.lastIndex = 0;
                }

                const matches = code.match(regex);

                if (matches) {
                    const matchCount = Math.min(matches.length, maxMatches);
                    this.#addScore(scores, langs, weight * matchCount);

                    // Track very strong matches (50+ weight)
                    if (weight >= 50) {
                        foundVeryStrong = true;
                    }
                }
            }

            return foundVeryStrong;
        }

        /**
         * Check for special cases like JSON, simple syntax patterns
         * @private
         * @param {string} code - Code to analyze
         * @param {Map<string, number>} scores - Score map to update
         */
        #checkSpecialCases(code, scores) {
            const trimmed = code.trim();

            // JSON detection - be more specific
            if ((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
                (trimmed.startsWith('[') && trimmed.endsWith(']'))) {

                // Additional JSON indicators
                const hasJsonPatterns = /^[\s\{\[]*"[\w\-]+"\s*:\s*/.test(trimmed) ||
                                      /"\s*:\s*[\[\{"]/.test(trimmed) ||
                                      /"\s*:\s*\d+/.test(trimmed);

                if (hasJsonPatterns) {
                    try {
                        JSON.parse(trimmed);
                        scores.set('json', (scores.get('json') || 0) + 30);
                        return; // Early return for confirmed JSON
                    } catch (e) {
                        // Not valid JSON, but might be similar syntax
                        if (hasJsonPatterns) {
                            this.#addScore(scores, ['javascript', 'typescript'], 5);
                        }
                    }
                }
            }

            // Quick syntax hint scoring - only if no strong matches yet
            const currentScores = Array.from(scores.values());
            const maxScore = currentScores.length > 0 ? Math.max(...currentScores) : 0;

            if (maxScore < 30) {
                if (code.includes('{') && code.includes('}')) {
                    this.#addScore(scores, ['javascript', 'java', 'cpp', 'csharp', 'go', 'rust', 'swift', 'actionscript'], 2);
                }

                if (code.includes(';')) {
                    this.#addScore(scores, ['javascript', 'java', 'cpp', 'csharp', 'go', 'rust', 'actionscript'], 2);
                }

                // Indentation hints
                const lines = code.split('\n');
                let indentedLines = 0;
                const maxLinesToCheck = Math.min(20, lines.length);

                for (let i = 0; i < maxLinesToCheck; i++) {
                    if (/^\s{4,}/.test(lines[i])) {
                        indentedLines++;
                    }
                }

                if (indentedLines > 3) {
                    this.#addScore(scores, ['python', 'yaml'], 3);
                }
            }

            // Check for specific file type indicators
            if (trimmed.includes('<?xml')) {
                scores.set('xml', (scores.get('xml') || 0) + 25);
            }

            if (trimmed.includes('<!DOCTYPE html')) {
                scores.set('html', (scores.get('html') || 0) + 25);
            }

            // Shell script indicators
            if (trimmed.startsWith('#!')) {
                const shebangLine = trimmed.split('\n')[0];
                if (shebangLine.includes('bash')) {
                    scores.set('bash', (scores.get('bash') || 0) + 20);
                } else if (shebangLine.includes('python')) {
                    scores.set('python', (scores.get('python') || 0) + 20);
                } else if (shebangLine.includes('ruby')) {
                    scores.set('ruby', (scores.get('ruby') || 0) + 20);
                } else if (shebangLine.includes('perl')) {
                    scores.set('perl', (scores.get('perl') || 0) + 20);
                }
            }
        }

        /**
         * Apply bias scoring to preferred languages
         * @private
         * @param {Map<string, number>} scores - Score map to update
         * @param {string[]} biasLanguages - Languages to bias towards
         * @param {number} biasWeight - Weight to add for biased languages
         */
        #applyBias(scores, biasLanguages, biasWeight = 5) {
            if (biasLanguages && biasLanguages.length > 0) {
                biasLanguages.forEach((lang) => {
                    if (scores.has(lang)) {
                        scores.set(lang, scores.get(lang) + biasWeight);
                    }
                });
            }
        }

        /**
         * Detect the most likely programming languages for the given code
         * @param {string} code - The code to analyze
         * @param {Object} options - Detection options
         * @param {string[]} [options.bias=[]] - Languages to bias detection towards
         * @param {number} [options.biasWeight=5] - Weight to add for biased languages
         * @param {number} [options.maxResults=5] - Maximum number of results to return
         * @returns {string[]} Array of detected languages, ordered by likelihood
         */
        detect(code, options = {}) {
            // Handle empty code gracefully
            if (code === null || code === undefined || code.length === 0) {
                return [];
            }

            // Handle edge cases
            if (!code || typeof code !== 'string') {
                return this.#defaultLanguages.slice(0, 3);
            }

            const trimmedCode = code.trim();
            if (trimmedCode.length === 0) {
                return this.#defaultLanguages.slice(0, 3);
            }

            // Extract options - limit to 5 results by default
            const { bias = [], biasWeight = 5, maxResults = 5 } = options;

            // Get strategic sample for analysis
            const sampleCode = this.#getSampleText(trimmedCode);
            const lowerCode = sampleCode.toLowerCase();
            const scores = new Map();

            // Process patterns in order of strength
            // Always process definitive patterns completely
            const foundDefinitive = this.#processPatterns(sampleCode, this.#patterns.definitive, scores, 3, false);

            // If we found definitive patterns, be more selective about other patterns
            if (foundDefinitive) {
                // Still process strong patterns but with more restraint
                this.#processPatterns(sampleCode, this.#patterns.strong, scores, 3);
                // Skip medium patterns if we have strong definitive matches
                const topScore = Math.max(...Array.from(scores.values()));
                if (topScore < 40) {
                    this.#processPatterns(sampleCode, this.#patterns.medium, scores, 5);
                }
            } else {
                // No definitive patterns found, process everything
                this.#processPatterns(sampleCode, this.#patterns.strong, scores, 5);
                this.#processPatterns(sampleCode, this.#patterns.medium, scores, 8);
                this.#processPatterns(lowerCode, this.#patterns.light, scores, 15);
            }

            // Always check special cases and template languages
            this.#processPatterns(sampleCode, this.#patterns.special, scores);
            this.#checkSpecialCases(sampleCode, scores);

            // Apply bias
            this.#applyBias(scores, bias, biasWeight);

            // Convert to sorted results
            const sortedResults = Array.from(scores.entries())
                .sort((a, b) => b[1] - a[1])
                .map(([lang]) => lang);

            // If no languages detected, return defaults
            if (sortedResults.length === 0) {
                return this.#defaultLanguages.slice(0, maxResults);
            }

            // Return detected languages, limited to maxResults
            return sortedResults.slice(0, maxResults);
        }

    }

    const languageDetector = new LanguageDetector();

    // Updated from package.json on build.
    const Version = '3.0.0';

    /**
     * @class Highlighter
     * @description Handles syntax highlighting of code blocks using Web Workers and intersection observers
     */
    class Highlighter {

        // Private static instance for singleton pattern
        static #instance = null;

        // Consolidated regex patterns
        #regex = {
            langValidation: /^[a-zA-Z]{2}(-[a-zA-Z]{2})?$/,
            lineBreak: /(<br[^>]*>)/gi,
            openingSpan: /<span[^>]*>/,
            closingSpan: /<\/span>/
        };

        // Configuration and state
        #autoLoad = true;
        #editor = new EditableHighlightJS();
        #hideNumbers = false;
        #ignoreElements = [];
        #lang = 'en-us';
        #lazyLoad = true;
        #minLineNumbers = 5;
        #minLineNumbersEnabled = false;
        #onlyAutoProcess = ['body'];
        #root = '';
        #worker = null;
        #version = Version;

        // DOMWatcher instance for efficient DOM observation
        #domWatcher = null;

        /**
         * @constructor
         * @param {string} scriptDirname Directory path for script resources
         * @param {Object} config Configuration options
         */
        constructor(scriptDirname, config = {}) {
            // Only the primary instance of HLJSL should auto run
            if (Highlighter.#instance) {
                return Highlighter.#instance;
            }
            Highlighter.#instance = this;

            window.languageDetector = languageDetector;

            // Record the script dirname
            this.#root = scriptDirname;

            // Initialize DOMWatcher
            this.#domWatcher = new DOMWatcher();

            // Run basic setup tasks and check GET parameters for config options
            this.#initialize();

            // Set or check for alternative config options
            if (Object.keys(config).length === 0) {
                this.#checkForGlobalConfig();
            } else {
                this.setConfig(config);
            }

            // Start processing code blocks once the body is loaded
            this.#initializeCodeProcessing();
        }

        /**
         * @param {Array} entries Observed intersection entries
         * @param {IntersectionObserver} observer The intersection observer instance
         */
        #blockInView(entries, observer) {
            // Process all intersecting entries at once
            const intersectingEntries = entries.filter((entry) => entry.isIntersecting);

            // Process highlighting as quickly as possible
            intersectingEntries.forEach((entry) => {
                this.highlight(entry.target);
            });

            // Batch the observer disconnection for better performance
            if (intersectingEntries.length > 0) {
                // Use a single timeout for all processed entries
                requestAnimationFrame(() => {
                    intersectingEntries.forEach((entry) => {
                        if (entry.target.hasAttribute('data-hljsl-id') &&
                            !entry.target.hasAttribute('data-unprocessed')) {
                            observer.unobserve(entry.target);
                        }
                    });
                });
            }
        }

        /**
         * Helper method that checks for and uses the users global config if set
         */
        #checkForGlobalConfig() {
            const globalConfig = window.hljslConfig;
            if (!globalConfig) return;
            this.setConfig(globalConfig);
        }

        /**
         * @returns {string} Unique identifier
         */
        createId() {
            return `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`.toUpperCase();
        }

        /**
         * Connect to HLJSL's web worker
         */
        connect() {
            if (this.#worker) return;
            const worker = new Worker(`${this.#root}/hljsl.min.js`);
            this.#worker = worker;
            worker.onmessage = this.#receiveResponse.bind(this);
        }

        /**
         * Copy code from a block to the users clipboard
         * @param {HTMLElement} evt The event that triggered this function
         */
        #copyToClipboard(evt) {
            let button = evt.currentTarget || evt.target;
            if (button.nodeName !== 'BUTTON') {
                button = button.closest('button');
            }
            if (!button) return;

            // Only process this event if we can find the table with the code to copy
            let pre = button.closest('code, pre');
            if (!pre) {
                pre = button.closest('div');
                if (!pre) return;

                pre = pre.nextElementSibling;
                if (!pre || pre.nodeName !== 'PRE') return;
            }
            // Helper function to remove common leading whitespace
            function dedent(text) {
                const lines = text.split('\n');
                const nonEmptyLines = lines.filter((line) => line.trim());
                if (nonEmptyLines.length === 0) return text;

                const minIndent = Math.min(...nonEmptyLines.map((line) => {
                    const match = line.match(/^[ \t]*/);
                    return match ? match[0].length : 0;
                }));

                return lines.map((line) => line.slice(minIndent)).join('\n');
            }

            let preText = '';
            let postText = '';
            if (pre.classList.contains('editor')) {
            // Check for preText (template before pre)
                const prev = pre.previousElementSibling;
                if (prev && prev.previousElementSibling) {
                    if (prev.previousElementSibling.nodeName === 'TEMPLATE') {
                        let rawText = prev.previousElementSibling.innerHTML.replace(/^\n/, '').replace(/\n$/, '');
                        rawText = dedent(rawText);
                        if (rawText) {
                            preText = rawText;
                        }
                    }
                }
                // Check for postText (template after pre)
                const next = pre.nextElementSibling;
                if (next && next.nodeName === 'TEMPLATE') {
                    let rawText = next.innerHTML.replace(/^\n/, '').replace(/\n$/, '');
                    rawText = dedent(rawText);
                    if (rawText) {
                        postText = `\n${rawText}`;
                    }
                }
            }

            const table = pre.querySelector('table');
            if (!table || !button) return;

            // Visually show the table is being copied
            button.ariaPressed = true;
            table.classList.add('copy-to-clipboard');

            // Remove the visual effect
            setTimeout(() => {
                table.classList.remove('copy-to-clipboard');
                button.ariaPressed = false;
            }, 500);

            // Copy the table to the users clipboard
            const cells = table.querySelectorAll('tr td:nth-child(2)');
            const tmpDiv = document.createElement('div');
            cells.forEach((cell) => {
                tmpDiv.textContent += `${cell.textContent}\n`;
            });

            const fullText = `${preText}${tmpDiv.textContent.trimEnd()}${postText}`;
            navigator.clipboard.writeText(fullText)
                .catch((error) => {
                    console.error('Failed to copy text to clipboard:', error);
                });
        }

        /**
         * @param {HTMLElement} elem The code element to process
         * @returns {HTMLElement} The processed code element
         */
        #correctPadding(elem) {
            // Don't waste time reprocessing a block
            if (elem.classList.contains('fixed-padding') ||
                elem.parentElement.classList.contains('fixed-padding') ||
                elem.querySelector('fixed-padding')
            ) return elem;

            // Enforce proper <pre><code> structure
            let pre;
            let code;
            if (elem.nodeName === 'PRE') {
                pre = elem;
                code = elem.querySelector('code');
                if (!code) {
                    code = document.createElement('CODE');
                    code.innerHTML = pre.innerHTML;
                    pre.innerHTML = '';
                    pre.appendChild(code);
                }
            } else if (elem.nodeName === 'CODE') {
                code = elem;
                pre = elem.closest('pre');
                if (!pre) {
                    pre = document.createElement('PRE');
                    code.parentElement.insertBefore(pre, elem);
                    pre.appendChild(code);
                }
            } else {
                pre = document.createElement('PRE');
                code = document.createElement('CODE');
                code.innerHTML = elem.innerHTML;
                pre.appendChild(code);
                elem.parentElement.insertBefore(pre, elem);
                elem.parentElement.removeChild(elem);
            }

            // Use innerHTML to preserve HTML entities when splitting into lines
            const lines = code.innerHTML.split('\n');

            // Handle first line edge case when it's on the same line as the code tag
            if (lines.length > 1 && lines[0].trim() !== '') {
                const firstLineIndent = lines[0].match(/^\s*/)[0].length;
                if (firstLineIndent === 0) {
                    const secondLineIndent = lines[1].match(/^\s*/)[0].length;
                    lines[0] = ' '.repeat(secondLineIndent) + lines[0];
                }
            }

            // Process all lines in a single pass
            let startIndex = 0;
            let endIndex = lines.length - 1;
            let minIndent = Infinity;

            // Find bounds and minimum indent in a single pass
            for (let i = 0; i < lines.length; i++) {
                const trimmed = lines[i].trim();

                // Skip empty lines at the start
                if (trimmed === '' && i === startIndex) {
                    startIndex++;
                    continue;
                }

                // Track last non-empty line
                if (trimmed !== '') {
                    endIndex = i;
                    // Calculate indent in the same loop
                    const indent = lines[i].length - trimmed.length;
                    if (indent < minIndent) minIndent = indent;
                }
            }

            // Safety check
            minIndent = minIndent === Infinity ? 0 : minIndent;

            // Extract and process lines in one go
            const processedLines = lines.slice(startIndex, endIndex + 1).map((line) =>
                (line.trim() === '' ? '' : line.substring(minIndent))
            );

            if (processedLines.length === 0) {
                processedLines.push('');
            }

            // Apply the processed content while preserving HTML entities
            code.innerHTML = processedLines.join('\n').trimEnd();
            code.classList.add('fixed-padding');

            // Clean up any extra whitespace in the pre tag
            pre.innerHTML = pre.innerHTML.trim();

            return pre.firstElementChild;
        }

        /**
         * Disconnect from HLJSL's web worker
         */
        disconnect() {
            if (!this.#worker) return;
            this.#worker.terminate();
            this.#worker = null;
            if (this.#domWatcher) {
                this.#domWatcher.disconnect();
                this.#domWatcher = null;
            }
        }

        /**
         * Returns the current auto-load processing status
         * @returns {boolean} True if auto processing is enabled, false otherwise
         */
        getAutoRunStatus() {
            return this.#autoLoad;
        }

        /**
         * Helper method to return the true innerText in a more reliant way
         * @param {HTMLElement} elem The element to get the true innerText from
         * @returns {string} The innerText always including newlines
         */
        #getTrueInnerText(elem) {
            return elem.innerHTML.replace(this.#regex.lineBreak, '\n');
        }

        /**
         * @param {array} find Array of element tags, classes, and/or ids to locate
         * @returns {string} The querySelectorAll string
         */
        getQuerySelectorFindAllString(find = []) {
            if (find.length === 0) return '';
            return find.join(', ');
        }

        /**
         * @param {string} find The query selector to find
         * @param {array} notWithin Array of elements to not search in
         * @returns {string} The proper query selector string
         */
        getQuerySelectorNotWithinString(find, notWithin = []) {
            if (notWithin.length === 0) return find;
            const ignoredSelectors = notWithin.join(', ');
            return `:not(${ignoredSelectors}) > ${find}`;
        }

        /**
         * @returns {string} The users valid BCP 47 language code
         */
        getUserLanguage() {
            let userLanguage = navigator.language || navigator.userLanguage;
            const htmlLang = document.documentElement.lang;
            if (htmlLang && this.#regex.langValidation.test(htmlLang)) {
                userLanguage = htmlLang;
            }
            return userLanguage;
        }

        /**
         * @returns {string} The current version of HLJSL
         */
        getVersion() {
            return this.#version;
        }

        /**
         * @param {HTMLElement} elem The code element to highlight
         */
        highlight(elem) {
            // Handle closed details elements
            const details = elem.closest('details');
            if (details && !details?.dataset?.hljslDelay) {
                details.dataset.hljslDelay = 'true';
                setTimeout(() => {
                    this.highlight(elem);
                }, 1);
                return;
            }

            // Ensure elem is a <code> element or find a suitable one
            if (elem.nodeName.toLowerCase() !== 'code') {
                const codeChild = elem.querySelector('code');
                if (codeChild) {
                    elem = codeChild;
                } else {
                    const codeParent = elem.closest('code');
                    if (codeParent) {
                        elem = codeParent;
                    } else {
                        // No <code> element found; bail
                        return;
                    }
                }
            }

            if (this.#hideNumbers) {
                elem.classList.add('hide-numbers');
            }

            if (!this.isConnected()) {
                this.connect();
            }

            if (elem.hasAttribute('data-hljsl-id') && elem.hasAttribute('data-unprocessed')) return;

            // If elem contains a table, handle it differently
            let innerText = '';
            if (elem.querySelector('table')) {
                const cells = elem.querySelectorAll('table tr td:nth-child(2)');
                innerText = Array.from(cells).map((cell) => cell.textContent).join('\n');
            } else {
                elem = this.#correctPadding(elem);
                elem.classList.add('hljs');
                elem.dataset.hljslId = this.createId();
                elem.dataset.unprocessed = 'true';
                innerText = this.#getTrueInnerText(elem);
            }

            // Check if element should be treated as an editor
            let editor = false;
            if (elem.classList.contains('editor') || elem.parentElement.classList.contains('editor')) {
                editor = true;
            }

            // Check if language should be locked; used for code editor mode
            let locked = false;
            if (elem.classList.contains('locked')) {
                locked = true;
            }

            const msg = {
                code: innerText,
                codeLang: elem.classList.toString(),
                editor,
                id: elem.dataset.hljslId,
                locked,
                pageLang: this.#lang
            };

            this.#worker.postMessage(msg);

            // Fail safe retry
            setTimeout(() => {
                if (elem.hasAttribute('data-unprocessed')) {
                    this.#worker.postMessage(msg);
                }
            }, 3000);
        }

        /**
         * @param {HTMLElement} container Optional container to search within
         */
        highlightAll(container) {
            // Cache selector creation for performance
            const selector = container ? 'pre code' :
                this.getQuerySelectorNotWithinString('pre code', this.#ignoreElements);

            if (!container) {
                // Cache these calculations
                const autoProcessSelector = this.getQuerySelectorFindAllString(this.#onlyAutoProcess);
                const containers = document.querySelectorAll(autoProcessSelector);

                // Process each container in batches
                for (let i = 0; i < containers.length; i++) {
                    const blocks = containers[i].querySelectorAll(selector);
                    for (let j = 0; j < blocks.length; j++) {
                        this.highlight(blocks[j]);
                    }
                }
                return;
            }

            // Process direct container
            const blocks = container.querySelectorAll(selector);
            for (let i = 0; i < blocks.length; i++) {
                this.highlight(blocks[i]);
            }
        }

        /**
         * Initialize HLJSL and check for settings
         */
        #initialize() {
            this.#lang = this.getUserLanguage();

            let hljsScriptSrc = '';
            const scripts = document.getElementsByTagName('script');
            for (let i = 0; i < scripts.length; i++) {
                const { src } = scripts[i];
                if (src.includes('hljsl.min.js')) {
                    if (src.indexOf('?')) {
                        hljsScriptSrc = src.substring(src.indexOf('?'));
                    }
                    break;
                }
            }

            const urlParams = new URLSearchParams(hljsScriptSrc);
            if (urlParams.get('autoLoad')) {
                this.#autoLoad = this.isTrue(urlParams.get('autoLoad'));
            }
            if (urlParams.get('hideNumbers')) {
                this.#hideNumbers = this.isTrue(urlParams.get('hideNumbers'));
            }
            if (urlParams.get('lazyLoad')) {
                this.#lazyLoad = this.isTrue(urlParams.get('lazyLoad'));
            }
            if (urlParams.get('minLineNumbers')) {
                const minLineNumbersParam = urlParams.get('minLineNumbers');
                if (minLineNumbersParam !== null) {
                    if (this.isTrue(minLineNumbersParam)) {
                        this.#minLineNumbersEnabled = true;
                    } else if (!isNaN(parseInt(minLineNumbersParam, 10))) {
                        this.#minLineNumbers = parseInt(minLineNumbersParam, 10);
                        this.#minLineNumbersEnabled = true;
                    } else {
                        this.#minLineNumbersEnabled = false;
                    }
                }
            }

            window.hljsl = this;
        }

        /**
         * Wait for the body to be loaded before processing code blocks
         * @returns {Promise} Resolves when the body is loaded
         */
        #initializeCodeProcessing() {
            if (!this.#autoLoad) return;

            this.#domWatcher.watch('pre code', (block) => {
                if (block.hasAttribute('data-hljsl-id') && !block.hasAttribute('data-unprocessed')) {
                    return;
                }

                if (this.#lazyLoad) {
                    const observer = new IntersectionObserver(
                        this.#blockInView.bind(this),
                        { root: null, rootMargin: '100%', threshold: 0 }
                    );
                    observer.observe(block);
                } else {
                    this.highlight(block);
                }
            }, false);
        }

        /**
         * @returns {boolean} Web worker connection state
         */
        isConnected() {
            return this.#worker !== null;
        }

        /**
         * @param {string} str String to convert to boolean
         * @returns {boolean} Converted boolean value
         */
        isTrue(str) {
            if (typeof str === 'string') {
                str = str.trim().toLowerCase();
            }
            switch (str) {
                case true:
                case 'true':
                case 1:
                case '1':
                case 'on':
                case 'yes':
                    return true;
                default:
                    return false;
            }
        }

        /**
         * Receives response from HLJSL's web worker
         * @param {MessageEvent} evt Response from web worker
         */
        #receiveResponse(evt) {
            const msg = evt.data;
            const elem = document.querySelector(`[data-hljsl-id="${msg.id}"]`);

            if (!elem) return;

            const pre = elem.closest('pre');
            if (!pre) return;

            elem.removeAttribute('data-unprocessed');
            elem.classList.forEach((cls) => {
                if (cls.startsWith('language-')) {
                    elem.classList.remove(cls);
                }
            });

            if (msg.language) {
                /**
                 * Language will always be a string but if isbl was detected or an
                 * error occurred it will be a comma separated list of languages.
                 */
                msg.language.split(',').forEach((lang) => {
                    elem.classList.add(`language-${lang.trim()}`);
                });
            }

            if (this.#minLineNumbersEnabled && msg.lines < this.#minLineNumbers) {
                elem.classList.add('hide-numbers');
            }

            if (pre.classList.contains('editor')) {
                pre.dataset.displayLanguage = msg.displayLanguage;
                this.#editor.deactivateEditor(pre);
            }

            // In editor mode, don't trim to preserve user's whitespace
            elem.innerHTML = msg.editor ? msg.code : msg.code.trim();
            elem.parentElement.classList.add('hljsl');
            elem.classList.add('hljs');
            elem.parentElement.innerHTML = elem.outerHTML.trim();

            const button = pre.querySelector('button.hljsl-clipboard');
            button.addEventListener('click', this.#copyToClipboard);
            button.addEventListener('keydown', this.#copyToClipboard);

            if (pre.classList.contains('editor')) {
                this.#editor.activateEditor(pre);
            }
        }

        /**
         * @param {object} config Settings to apply
         */
        setConfig(config) {
            if (this.whatIs(config) !== 'object') return;

            if (this.whatIs(config.autoLoad) === 'boolean') {
                this.#autoLoad = config.autoLoad;
            }

            if (this.whatIs(config.hideNumbers) === 'boolean') {
                this.#hideNumbers = config.hideNumbers;
            }

            if (this.whatIs(config.ignoreElements) === 'array') {
                this.#ignoreElements = config.ignoreElements;
            }

            if (this.whatIs(config.lang) === 'string') {
                this.#lang = config.lang;
            }

            if (this.whatIs(config.lazyLoad) === 'boolean') {
                this.#lazyLoad = config.lazyLoad;
            }

            if (this.whatIs(config.minLineNumbers) === 'boolean') {
                this.#minLineNumbersEnabled = config.minLineNumbers;
            } else if (this.whatIs(config.minLineNumbers) === 'number') {
                this.#minLineNumbers = config.minLineNumbers;
                this.#minLineNumbersEnabled = true;
            }

            if (this.whatIs(config.onlyAutoProcess) === 'array' && config.onlyAutoProcess.length > 0) {
                this.#onlyAutoProcess = config.onlyAutoProcess;
            }
        }

        /**
         * Get the type of any value
         * @param {*} unknown Value to check type of
         * @return {string|undefined} Type in lowercase or undefined
         */
        whatIs(unknown) {
            try {
                return {}.toString.call(unknown).match(/\s([^\]]+)/)[1].toLowerCase();
            } catch (e) { return undefined; }
        }

    }

    /**
     * @fileoverview i18n translations for the "Copy to Clipboard" button.
     */
    const copyToClipboardMap = {
        af: 'Kopieer kode na knipbord',
        am: 'ኮድ ኮድ በቁምፊዎች ውስጥ አጽዳ',
        ar: 'نسخ الكود إلى الحافظة',
        az: 'Kodunu kopyala',
        be: 'Скапіраваць код у буфер абмену',
        bg: 'Копиране на код в клипборда',
        bn: 'কোড ক্লিপবোর্ডে কপি করুন',
        bs: 'Kopiraj kod u međuspremnik',
        ca: 'Copiar el codi al porta-retalls',
        cs: 'Kopírovat kód do schránky',
        cy: "Copïo cod i'r clipfwrdd",
        da: 'Kopier kode til udklipsholderen',
        de: 'Code in die Zwischenablage kopieren',
        el: 'Αντιγραφή κώδικα στο πρόχειρο',
        en: 'Copy code to clipboard',
        es: 'Copiar código al portapapeles',
        et: 'Kopeeri kood lõikelauale',
        eu: 'Kodea arbelean kopiatu',
        fa: 'کپی کد به کلیپ بورد',
        fi: 'Kopioi koodi leikepöydälle',
        fil: 'Kopyahin ang code sa clipboard',
        fr: 'Copier le code dans le presse-papiers',
        ga: 'Cóipeáil an cód chuig an ghréasán',
        gl: 'Copiar o código no portapapeis',
        gu: 'કોડને ક્લિપબોર્ડ પર કપિ કરો',
        he: 'העתק קוד ללוח',
        hi: 'कोड को क्लिपबोर्ड पर कॉपी करें',
        hr: 'Kopiraj kod u međuspremnik',
        hu: 'Kód másolása a vágólapra',
        hy: 'Պատճենել ծրագիրը բֆերում',
        id: 'Salin kode ke papan klip',
        is: 'Afrita kóða í klippiborð',
        it: 'Copia codice negli appunti',
        ja: 'コードをクリップボードにコピー',
        ka: 'კოდის კოპირება ბუფერში',
        kk: 'Кодты буферге көшіру',
        km: 'ចម្លងកូដ​ទៅ​ក្ដារ​ប្លុក​កម្មវិធី',
        kn: 'ಕೋಡ್ ಅನ್ನು ಕ್ಲಿಪ್‌ಬೋರ್ಡ್‌ಗೆ ನಕಲಿಸಿ',
        ko: '코드를 클립보드에 복사',
        ku: 'Koda li clipboardê bixwîne',
        ky: 'Коду буферге көчүр',
        lo: 'ສຳ ເນົາ ໂຄດ ໃສ່ ບາດປະ ເພດ',
        lt: 'Kopijuoti kodą į iškarpinę',
        lv: 'Kopēt kodu uz starpliktuvi',
        mk: 'Копирајте го кодот во клипборд',
        ml: 'കോഡ് ക്ലിപ്പ്‌ബോര്‍ഡിലേക്ക് പകർത്തുക',
        mn: 'Кодыг хавтас руу хуулах',
        mr: 'कोड क्लिपबोर्डवर कॉपी करा',
        ms: 'Salin kod ke papan klip',
        my: 'ကုဒ်ကို clipboard သို့ ကူးယူပါ',
        ne: 'कोडलाई क्लिपबोर्डमा कपि गर्नुहोस्',
        nl: 'Code kopiëren naar klembord',
        nn: 'Kopier kode til utklippstavle',
        no: 'Kopier kode til utklippstavle',
        or: 'କୋଡକୁ କ୍ଲିପବୋର୍ଡରେ କପି କରନ୍ତୁ',
        pa: "ਕੋਡ ਨੂੰ ਕਲਿੱਪਬੋਰਡ 'ਤੇ ਕਾਪੀ ਕਰੋ",
        pl: 'Skopiuj kod do schowka',
        pt: 'Copiar código para a área de transferência',
        ro: 'Copiază codul în clipboard',
        ru: 'Копировать код в буфер обмена',
        si: 'කේතය ක්ලිප් බෝඩ්යයට පිටුවට අනුකූල කරන්න',
        sk: 'Kopírovať kód do schránky',
        sl: 'Kopiraj kodo v odložišče',
        sq: 'Kopjo kodin në clipboard',
        sr: 'Копирај код у међуспремник',
        sv: 'Kopiera kod till urklipp',
        sw: 'Nakili kanuni kwenye ubao wa kunakili',
        ta: 'குறியீட்டை கிளிப்போர்டுக்கு நகலிக்கவும்',
        te: 'కోడ్ను క్లిప్‌బోర్డ్‌కు కాపీ చేయండి',
        th: 'คัดลอกโค้ดไปยังคลิปบอร์ด',
        tl: 'Kopyahin ang code sa clipboard',
        tr: 'Kodu panoya kopyala',
        uk: 'Скопіювати код у буфер обміну',
        ur: 'کوڈ کو کلپ بورڈ پر کاپی کریں',
        uz: 'Kodni joylashtirish saqlab olish',
        vi: 'Sao chép mã vào clipboard',
        yo: 'Fikun koodu si afikun',
        zh: '复制代码到剪贴板',
        zu: 'Casha ikhodi ekopishweni'
    };

    /**
     * @fileoverview List of languages loaded and supported by HLJSL and by extension, Highlight.js.
     * Note that html has been added to this list so we can later catch it and apply django and xml.
     */

    // List of all supported language codes; don't allow duplicates
    const languageCodes = new Set([
        // eslint-disable-next-line max-len
        '1c', 'abnf', 'accesslog', 'actionscript', 'ada', 'angelscript', 'apache', 'applescript', 'arcade', 'arduino', 'armasm', 'asciidoc', 'aspectj', 'autohotkey', 'autoit', 'avrasm', 'awk', 'axapta', 'bash', 'basic', 'bnf', 'brainfuck', 'c', 'cal', 'capnproto', 'ceylon', 'clean', 'clojure-repl', 'clojure', 'cmake', 'coffeescript', 'coq', 'cos', 'cpp', 'crmsh', 'crystal', 'csharp', 'csp', 'css', 'd', 'dart', 'delphi', 'diff', 'django', 'dns', 'dockerfile', 'dos', 'dsconfig', 'dts', 'dust', 'ebnf', 'elixir', 'elm', 'erb', 'erlang-repl', 'erlang', 'excel', 'fix', 'flix', 'fortran', 'fsharp', 'gams', 'gauss', 'gcode', 'gherkin', 'glsl', 'gml', 'go', 'golo', 'gradle', 'graphql', 'groovy', 'haml', 'handlebars', 'haskell', 'haxe', 'hsp', 'html', 'http', 'hy', 'inform7', 'ini', 'irpf90', 'isbl', 'java', 'javascript', 'js', 'jboss-cli', 'json', 'julia-repl', 'julia', 'kotlin', 'lasso', 'latex', 'ldif', 'leaf', 'less', 'lisp', 'livecodeserver', 'livescript', 'llvm', 'lsl', 'lua', 'makefile', 'markdown', 'mathematica', 'matlab', 'maxima', 'md', 'mel', 'mercury', 'mipsasm', 'mizar', 'mojolicious', 'monkey', 'moonscript', 'n1ql', 'nestedtext', 'nginx', 'nim', 'nix', 'node-repl', 'nsis', 'objectivec', 'ocaml', 'openscad', 'oxygene', 'parser3', 'perl', 'pf', 'pgsql', 'php-template', 'php', 'plaintext', 'pony', 'powershell', 'processing', 'profile', 'prolog', 'properties', 'protobuf', 'puppet', 'purebasic', 'python-repl', 'python', 'q', 'qml', 'r', 'reasonml', 'rib', 'roboconf', 'routeros', 'rsl', 'ruby', 'ruleslanguage', 'rust', 'sas', 'scala', 'scheme', 'scilab', 'scss', 'shell', 'smali', 'smalltalk', 'sml', 'sqf', 'sql', 'stan', 'stata', 'step21', 'stylus', 'subunit', 'swift', 'taggerscript', 'tap', 'tcl', 'thrift', 'tp', 'twig', 'typescript', 'ts', 'vala', 'vbnet', 'vbscript-html', 'vbscript', 'verilog', 'vhdl', 'vim', 'wasm', 'wren', 'x86asm', 'xl', 'xml', 'xquery', 'yaml', 'zephir'
    ]);

    // Map of highlighter language codes to user-friendly names
    const languageDisplayNames = new Map([
        ['1c', '1C'],
        ['abnf', 'ABNF'],
        ['accesslog', 'Access Log'],
        ['actionscript', 'ActionScript'],
        ['ada', 'Ada'],
        ['angelscript', 'AngelScript'],
        ['apache', 'Apache'],
        ['applescript', 'AppleScript'],
        ['arcade', 'Arcade'],
        ['arduino', 'Arduino'],
        ['armasm', 'ARM Assembly'],
        ['asciidoc', 'AsciiDoc'],
        ['aspectj', 'AspectJ'],
        ['autohotkey', 'AutoHotkey'],
        ['autoit', 'AutoIt'],
        ['avrasm', 'AVR Assembly'],
        ['awk', 'Awk'],
        ['axapta', 'Axapta'],
        ['bash', 'Bash'],
        ['basic', 'Basic'],
        ['bnf', 'BNF'],
        ['brainfuck', 'Brainfuck'],
        ['c', 'C'],
        ['cal', 'Cal'],
        ['capnproto', "Cap'n Proto"],
        ['ceylon', 'Ceylon'],
        ['clean', 'Clean'],
        ['clojure-repl', 'Clojure REPL'],
        ['clojure', 'Clojure'],
        ['cmake', 'CMake'],
        ['coffeescript', 'CoffeeScript'],
        ['coq', 'Coq'],
        ['cos', 'Cache Object Script'],
        ['cpp', 'C++'],
        ['crmsh', 'crmsh'],
        ['crystal', 'Crystal'],
        ['csharp', 'C#'],
        ['csp', 'CSP'],
        ['css', 'CSS'],
        ['d', 'D'],
        ['dart', 'Dart'],
        ['delphi', 'Delphi'],
        ['diff', 'Diff'],
        ['django', 'Django'],
        ['dns', 'DNS'],
        ['dockerfile', 'Dockerfile'],
        ['dos', 'DOS'],
        ['dsconfig', 'dsconfig'],
        ['dts', 'Device Tree'],
        ['dust', 'Dust'],
        ['ebnf', 'EBNF'],
        ['elixir', 'Elixir'],
        ['elm', 'Elm'],
        ['erb', 'ERB'],
        ['erlang-repl', 'Erlang REPL'],
        ['erlang', 'Erlang'],
        ['excel', 'Excel'],
        ['fix', 'FIX'],
        ['flix', 'Flix'],
        ['fortran', 'Fortran'],
        ['fsharp', 'F#'],
        ['gams', 'GAMS'],
        ['gauss', 'GAUSS'],
        ['gcode', 'G-Code'],
        ['gherkin', 'Gherkin'],
        ['glsl', 'GLSL'],
        ['gml', 'GML'],
        ['go', 'Go'],
        ['golo', 'Golo'],
        ['gradle', 'Gradle'],
        ['graphql', 'GraphQL'],
        ['groovy', 'Groovy'],
        ['haml', 'Haml'],
        ['handlebars', 'Handlebars'],
        ['haskell', 'Haskell'],
        ['haxe', 'Haxe'],
        ['hsp', 'HSP'],
        ['html', 'HTML'],
        ['http', 'HTTP'],
        ['hy', 'Hy'],
        ['inform7', 'Inform 7'],
        ['ini', 'INI'],
        ['irpf90', 'IRPF90'],
        ['isbl', 'ISBL'],
        ['java', 'Java'],
        ['javascript', 'JavaScript'],
        ['js', 'JavaScript'],
        ['jboss-cli', 'JBoss CLI'],
        ['json', 'JSON'],
        ['julia-repl', 'Julia REPL'],
        ['julia', 'Julia'],
        ['kotlin', 'Kotlin'],
        ['lasso', 'Lasso'],
        ['latex', 'LaTeX'],
        ['ldif', 'LDIF'],
        ['leaf', 'Leaf'],
        ['less', 'Less'],
        ['lisp', 'Lisp'],
        ['livecodeserver', 'LiveCode Server'],
        ['livescript', 'LiveScript'],
        ['llvm', 'LLVM IR'],
        ['lsl', 'LSL'],
        ['lua', 'Lua'],
        ['makefile', 'Makefile'],
        ['markdown', 'Markdown'],
        ['mathematica', 'Mathematica'],
        ['matlab', 'MATLAB'],
        ['maxima', 'Maxima'],
        ['md', 'Markdown'],
        ['mel', 'MEL'],
        ['mercury', 'Mercury'],
        ['mipsasm', 'MIPS Assembly'],
        ['mizar', 'Mizar'],
        ['mojolicious', 'Mojolicious'],
        ['monkey', 'Monkey'],
        ['moonscript', 'MoonScript'],
        ['n1ql', 'N1QL'],
        ['nestedtext', 'NestedText'],
        ['nginx', 'Nginx'],
        ['nim', 'Nim'],
        ['nix', 'Nix'],
        ['node-repl', 'Node.js REPL'],
        ['nsis', 'NSIS'],
        ['objectivec', 'Objective-C'],
        ['ocaml', 'OCaml'],
        ['openscad', 'OpenSCAD'],
        ['oxygene', 'Oxygene'],
        ['parser3', 'Parser3'],
        ['perl', 'Perl'],
        ['pf', 'PF'],
        ['pgsql', 'PostgreSQL'],
        ['php-template', 'PHP Template'],
        ['php', 'PHP'],
        ['plaintext', 'Plain Text'],
        ['pony', 'Pony'],
        ['powershell', 'PowerShell'],
        ['processing', 'Processing'],
        ['profile', 'Profile'],
        ['prolog', 'Prolog'],
        ['properties', 'Properties'],
        ['protobuf', 'Protocol Buffers'],
        ['puppet', 'Puppet'],
        ['purebasic', 'PureBasic'],
        ['python-repl', 'Python REPL'],
        ['python', 'Python'],
        ['q', 'Q'],
        ['qml', 'QML'],
        ['r', 'R'],
        ['reasonml', 'ReasonML'],
        ['rib', 'RenderMan RIB'],
        ['roboconf', 'Roboconf'],
        ['routeros', 'RouterOS'],
        ['rsl', 'RSL'],
        ['ruby', 'Ruby'],
        ['ruleslanguage', 'Rules Language'],
        ['rust', 'Rust'],
        ['sas', 'SAS'],
        ['scala', 'Scala'],
        ['scheme', 'Scheme'],
        ['scilab', 'Scilab'],
        ['scss', 'SCSS'],
        ['shell', 'Shell'],
        ['smali', 'Smali'],
        ['smalltalk', 'Smalltalk'],
        ['sml', 'SML'],
        ['sqf', 'SQF'],
        ['sql', 'SQL'],
        ['stan', 'Stan'],
        ['stata', 'Stata'],
        ['step21', 'STEP Part 21'],
        ['stylus', 'Stylus'],
        ['subunit', 'SubUnit'],
        ['swift', 'Swift'],
        ['taggerscript', 'Tagger Script'],
        ['tap', 'TAP'],
        ['tcl', 'Tcl'],
        ['thrift', 'Thrift'],
        ['tp', 'TP'],
        ['twig', 'Twig'],
        ['typescript', 'TypeScript'],
        ['ts', 'TypeScript'],
        ['vala', 'Vala'],
        ['vbnet', 'Visual Basic .NET'],
        ['vbscript-html', 'VBScript in HTML'],
        ['vbscript', 'VBScript'],
        ['verilog', 'Verilog'],
        ['vhdl', 'VHDL'],
        ['vim', 'Vim Script'],
        ['wasm', 'WebAssembly'],
        ['wren', 'Wren'],
        ['x86asm', 'x86 Assembly'],
        ['xl', 'XL'],
        ['xml', 'XML'],
        ['xquery', 'XQuery'],
        ['yaml', 'YAML'],
        ['zephir', 'Zephir']
    ]);

    /**
     * @typedef {Object} MessageData
     * @property {string} id Unique identifier for the message
     * @property {string} pageLang Language code for the page
     * @property {string} code Code to be highlighted
     * @property {string} codeLang Language(s) specified for the code
     */

    /**
     * @typedef {Object} HighlightResult
     * @property {string} value Highlighted code HTML
     * @property {string} [language] Detected language
     * @property {Object} [secondBest] Second best language match
     * @property {string} secondBest.language Second best detected language
     */

    /**
     * Web worker class for syntax highlighting code using highlight.js
     */
    class Webworker {

        // Private static property to hold the instance
        static #instance;

        // Map of HTML entities to their symbol representations
        #commonEntityMap = new Map([
            ['&lt;', { symbol: '<', regex: /&lt;/g }],
            ['&gt;', { symbol: '>', regex: /&gt;/g }],
            ['&amp;', { symbol: '&', regex: /&amp;/g }],
            ['&quot;', { symbol: '"', regex: /&quot;/g }],
            ['&apos;', { symbol: "'", regex: /&apos;/g }],
            ['&semi;', { symbol: ';', regex: /&semi;/g }]
        ]);

        // Pre-compiled regex patterns for detecting various template syntaxes
        #possibleJsTemplate = Object.freeze([
            // EJS-style patterns
            /(?:<|&lt;)%.*?%(?:>|&gt;)/,                   // Basic EJS
            /(?:<|&lt;)%=.*?%(?:>|&gt;)/,                  // EJS output
            /(?:<|&lt;)%-.*?%(?:>|&gt;)/,                  // EJS unescaped output
            /(?:<|&lt;)%#.*?%(?:>|&gt;)/,                  // EJS comments
            // Handlebars/Mustache patterns
            /\{\{.*?\}\}/,                                 // Basic interpolation
            /\{\{#.*?\}\}.*?\{\{\/.*?\}\}/,                // Block helpers
            /\{\{!.*?\}\}/,                                // Comments
            /\{\{>.*?\}\}/,                                // Partials
            /\{\{#if\s+.*?\}\}.*?\{\{\/if\}\}/,            // Conditionals
            /\{\{#each\s+.*?\}\}.*?\{\{\/each\}\}/,        // Iteration
            // Other template engines
            /\{%.*?%\}/,                                   // Nunjucks/Liquid/Twig blocks
            /\{#.*?#\}/,                                   // Jinja2 comments
            /\{%.*?\s+.*?\s*%\}/,                          // Twig blocks
            /(?:<|&lt;)%-.*?%(?:>|&gt;)/,                  // Pug unescaped output
            /\{\{%.*?%\}\}/,                               // Twig special blocks
            // Generic patterns
            /(?:\{\{|(?:<|&lt;)%).*?for\s+.*?\s+in\s+.*?/, // Generic iteration
            /\{\{.*?\|.*?\}\}/                             // Filter syntax
        ]);

        // Class level regex patterns for span detection
        #spanPatterns = {
            opening: /<span[^>]*>/,
            closing: /<\/span>/
        };

        /**
         * Initialize the web worker and set up highlight.js
         * @param {string} scriptDirname Directory path for the highlight.js script
         */
        constructor(scriptDirname) {
            if (Webworker.#instance) {
                return Webworker.#instance;
            }

            try {
                importScripts(`${scriptDirname}hljs.min.js`);
                this.#registerAliases();
                self.onmessage = this.#onMessage.bind(this);
                Webworker.#instance = this;
            } catch (error) {
                console.error('Failed to initialize webworker:', error);
                throw error;
            }
        }

        /**
         * Builds the HTML for a "Copy to Clipboard" button
         * @param {string} pageLang The language code for button text
         * @returns {string} HTML markup for the button
         */
        #buildCopyToClipboardButton(pageLang) {
            const langKey = pageLang.toLowerCase().split('-')[0];
            const title = copyToClipboardMap[langKey] ?? copyToClipboardMap.en;

            /* eslint-disable */
            return `<button type="button" aria-pressed="false" class="hljsl-clipboard" title="${title}">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <path d="M21 2h-19v19h-2v-21h21v2zm3 2v20h-20v-20h20zm-2 2h-1.93c-.669 0-1.293.334-1.664.891l-1.406 2.109h-6l-1.406-2.109c-.371-.557-.995-.891-1.664-.891h-1.93v16h16v-16zm-3 6h-10v1h10v-1zm0 3h-10v1h10v-1zm0 3h-10v1h10v-1z"/>
            </svg>
        </button>`.replace(/\s+/g, ' ').trim();
            /* eslint-enable */
        }

        /**
         * Builds an HTML table with line numbers from highlighted code
         * @param {string} code The highlighted code HTML
         * @param {string} [pageLang='en'] Language code for the copy button
         * @param {boolean} [editor=false] Whether the code is for an editor element
         * @returns {{table: string, lines: number}} Table HTML and line count
         */
        #buildTable(code, pageLang = 'en', editor = false) {
        // In editor mode, preserve whitespace including trailing newlines
            const lines = editor ? code.split('\n') : code.trim().split('\n');
            const copyButton = this.#buildCopyToClipboardButton(pageLang);

            // Start building HTML
            let html = `${copyButton}<table class="hljsl-table"><tbody>`;

            let openSpan = '';
            const openingPattern = this.#spanPatterns.opening;
            const closingPattern = this.#spanPatterns.closing;

            // Process actual code lines
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];

                // Handle span continuation
                if (openSpan) {
                    line = openSpan + line;
                }

                const openingMatch = line.match(openingPattern);
                const closingMatch = line.match(closingPattern);

                if (openingMatch && !closingMatch) {
                    // eslint-disable-next-line prefer-destructuring
                    openSpan = openingMatch[0];
                } else if (closingMatch) {
                    openSpan = '';
                }

                // Ensure empty lines are copyable
                if (!line) {
                    line = '<span></span>';
                }

                html += `<tr><td>${i + 1}</td><td>${line}</td></tr>`;
            }

            /**
             * Add extra lines for editor mode if needed
             * @deprecated
             * if (editor && lines.length === 1) {
             *     html += `<tr><td>${lines.length + 1}</td><td><span></span></td></tr>`;
             *     html += `<tr><td>${lines.length + 2}</td><td><span></span></td></tr>`;
             * }
             */

            html += '</tbody></table>';

            const totalLines = editor && lines.length === 1 ? lines.length + 2 : lines.length;

            return {
                table: html,
                lines: totalLines
            };
        }

        /**
         * Determine what the display language should be based on the first recognized language class
         * @param {array} langs An array of possible code languages
         * @param {boolean} [withKey] Should the key be returned for the matching language as well; default false
         * @returns The language name meant for display or null if not determined
         */
        #getDisplayLanguage(langs, withKey = false) {
            for (let lang of langs) {
                lang = lang.trim();
                if (languageDisplayNames.has(lang)) {
                    if (withKey) {
                        return { key: lang, val: languageDisplayNames.get(lang) };
                    }
                    return languageDisplayNames.get(lang);
                }
            }
            if (withKey) {
                return { key: null, val: null };
            }
            return null;
        }

        /**
         * Handles incoming messages for code highlighting
         * @param {MessageEvent<string>} evt The message event containing the code
         */
        #onMessage(evt) {
            const msg = evt.data;
            const { id, pageLang, code, editor, locked } = msg;
            let codeLang = this.#processLanguages(msg.codeLang, code);
            let displayLanguage = this.#getDisplayLanguage(codeLang); // Preset in case an error occurs

            if (editor && !locked) {
                codeLang = languageDetector.detect(code, { bias: codeLang });
                displayLanguage = null;
            }

            try {
                const preprocessedCode = this.#preprocessCode(code);
                let result = this.#highlightCode(preprocessedCode, codeLang);

                // If no language was detected try the second best
                if (!result.language && result?.secondBest?.language) {
                    result = result.secondBest;
                }

                const { table, lines } = this.#buildTable(result.value, pageLang, editor);

                // Correct common edge-case in language detection; we usually want python in this case
                if (result.language === 'isbl') {
                    result.language = 'python, isbl';
                }

                // We highlight HTML as Django, correct this so the display language shows HTML still
                if (codeLang[0] && codeLang[0] === 'django') {
                    codeLang.unshift('html');
                }

                let languageKey = '';

                // Determine language key and display value based on locked status
                if (locked && codeLang[0] && languageDisplayNames.has(codeLang[0])) {
                // Case 1: Locked with valid language in codeLang[0]
                    displayLanguage = languageDisplayNames.get(codeLang[0]);
                    // eslint-disable-next-line prefer-destructuring
                    languageKey = codeLang[0];
                } else if (locked) {
                // Case 2: Locked but need to get display language; this will now be the locked language
                    const langData = this.#getDisplayLanguage(codeLang, true);
                    displayLanguage = langData.val;
                    languageKey = langData.key;
                } else if (code === null || code === undefined || code.trim() === '') {
                // Case 3: Empty code, default to plaintext
                    displayLanguage = ['Plaintext'];
                    languageKey = 'plaintext';
                } else {
                // Case 4: Not locked
                    const langData = this.#getDisplayLanguage(result.language.split(','), true);
                    displayLanguage = langData.val;
                    languageKey = langData.key;
                }

                // Set the result language after determining the correct value
                result.language = languageKey;

                self.postMessage({
                    code: table,
                    id,
                    displayLanguage,
                    language: result.language,
                    lines,
                    locked,
                    editor // Pass editor flag back so highlighter knows not to trim
                });
            } catch (error) {
                const copyButton = this.#buildCopyToClipboardButton(pageLang);
                const table = `
            ${copyButton}<table class="hljsl-table">
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>${error}</td>
                    </tr>
                </tbody>
            </table>`;

                self.postMessage({
                    code: table,
                    id,
                    displayLanguage,
                    language: codeLang.join(','),
                    lines: error.toString().split('\n').length,
                    locked,
                    editor
                });
            }
        }

        /**
         * Processes and expands language hints for better detection
         * @param {string} codeLang Original language string
         * @param {string} code The code to analyze
         * @returns {string[]} Expanded array of language hints
         */
        #processLanguages(codeLang, code) {
            let langs = codeLang.toLowerCase().split(' ')
                .filter((value) => languageCodes.has(value));

            // If no languages were specified, try to detect them
            if (langs.length === 0) {
                return [];
            }

            // Help highlight languages that are commonly broken during the highlighting process
            if (langs.includes('css')) {
                langs.push('scss', 'less');
            }

            if (langs.includes('html')) {
                langs = langs.filter((lang) => lang !== 'html' && lang !== 'language-html');
                langs.push('django');
                if (this.#possibleJsTemplate.some((regex) => regex.test(code))) {
                    langs.push('javascript');
                }
                langs.push('xml');
            }

            if (langs.includes('ini')) {
                langs.push('abnf', 'yaml');
            }

            if (langs.includes('php')) {
                langs.push('php-template');
            }

            return langs;
        }

        /**
         * Preprocesses code by converting HTML entities to symbols
         * @param {string} code Raw code with HTML entities
         * @returns {string} Processed code with actual symbols
         */
        #preprocessCode(code) {
            let result = code;
            for (const [, { symbol, regex }] of this.#commonEntityMap) {
                result = result.replace(regex, symbol);
            }
            return result;
        }

        /**
         * Highlights code using highlight.js
         * @param {string} code Code to highlight
         * @param {string[]} languages Array of language hints
         * @returns {HighlightResult} Highlighted code result
         */
        #highlightCode(code, languages) {
            return languages.length && languages[0] ?
                self.hljs.highlightAuto(code, languages) :
                self.hljs.highlightAuto(code);
        }

        /**
         * Registers language aliases for highlight.js
         * Helps with language detection by mapping variant names
         */
        #registerAliases() {
            self.hljs.registerAliases(['md'], { languageName: 'markdown' });
            self.hljs.registerAliases(['py'], { languageName: 'python' });
            self.hljs.registerAliases(['vim-script'], { languageName: 'vim' });
            self.hljs.registerAliases(
                ['php5', 'php6', 'php7', 'php8', 'php9'],
                { languageName: 'php' }
            );
        }

    }

    /**
    * @fileoverview Entry point for HLJSL that handles initialization in different environments
    * and manages singleton instances of the Highlighter and Webworker classes.
    */


    /**
    * Gets the running script's directory path for all environments
    * @returns {string} Absolute path to the directory containing this script
    */
    const scriptDirname = (() => {
        const absolutePath = (scriptUrl) => {
            const path = scriptUrl.pathname.endsWith('/') ?
                scriptUrl.pathname :
                scriptUrl.pathname.substring(0, scriptUrl.pathname.lastIndexOf('/') + 1);
            return scriptUrl.origin + path.replace(/\/{2,}/g, '/');
        };

        // Web Worker environment
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            return absolutePath(new URL(self.location.href));
        }

        // Non-module script environment
        if (typeof document !== 'undefined' && document.currentScript) {
            return absolutePath(new URL(document.currentScript.src));
        }

        // ES module environment
        if (typeof ({ url: (_documentCurrentScript && _documentCurrentScript.src || new URL('hljsl.min.js', document.baseURI).href) }) !== 'undefined' && (_documentCurrentScript && _documentCurrentScript.src || new URL('hljsl.min.js', document.baseURI).href)) {
            return absolutePath(new URL((_documentCurrentScript && _documentCurrentScript.src || new URL('hljsl.min.js', document.baseURI).href)));
        }
    })();

    // Environment detection
    const isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;

    // Singleton instances
    let instance = null;

    /**
    * Initializes HLJSL in the appropriate environment
    * @param {Object} config Configuration options for Highlighter
    * @returns {Highlighter|Webworker} The appropriate singleton instance
    */
    const InitializeHljsl = (config = {}) => {
        if (instance) return instance;

        instance = isWorker ?
            new Webworker(scriptDirname) :
            new Highlighter(scriptDirname, config);

        return instance;
    };

    // Auto-initialize in the appropriate environment
    if (isWorker) {
        InitializeHljsl();
    } else {
        window.hljsl = InitializeHljsl();
    }

})();
