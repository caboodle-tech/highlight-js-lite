{"version":3,"file":"hljsl.min.js","sources":["../src/hljsl.js"],"sourcesContent":["let autoRunCompleted = false;\n\n/* eslint-disable no-param-reassign */\nclass HighlightLite {\n\n    #autoLoad = true;\n\n    #hideNumbers = false;\n\n    #ignoreElements = [];\n\n    #lang = 'en-us';\n\n    #lazyLoad = true;\n\n    #onlyAutoProcess = ['body'];\n\n    #root = '';\n\n    #worker = null;\n\n    #version = '1.1.0';\n\n    constructor(config = {}) {\n        this.#initialize();\n        // Set or check for alternative config options.\n        if (Object.keys(config).length === 0) {\n            this.#checkForGlobalConfig();\n        } else {\n            this.setConfig(config);\n        }\n        // Only the primary instance of HLJSL should auto run.\n        if (autoRunCompleted) { return; }\n        autoRunCompleted = true;\n        this.#waitForBody();\n    }\n\n    /**\n     * Watch a block for intersection events and when it appears to be coming up\n     * in the viewport (or already showing), process the block. This is used to\n     * lazy process (load) code blocks.\n     *\n     * @param {Array} entries An array of observed events that have triggered this function.\n     * @param {IntersectionObserver} observer The observer watching this element/event.\n     */\n    #blockInView(entries, observer) {\n        entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n                observer.disconnect(); // Block is about to be processed so stop watching it.\n                this.highlight(entry.target);\n            }\n        });\n    }\n\n    /**\n     * Helper method that checks for and uses the users global config if set.\n     */\n    #checkForGlobalConfig() {\n        const globalConfig = window.hljslConfig;\n        if (!globalConfig) { return; }\n        this.setConfig(globalConfig);\n    }\n\n    /**\n     * Create a unique id.\n     *\n     * @returns {string} A generally unique id.\n     */\n    createId() {\n        return `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`.toUpperCase();\n    }\n\n    /**\n     * Connect to HLJSL's web worker.\n     *\n     * @returns {void} Used as a short circuit only.\n     */\n    connect() {\n        if (this.#worker) {\n            return;\n        }\n        const worker = new Worker(`${this.#root}/hljsl-worker.min.js`);\n        worker.onmessage = this.#receiveResponse.bind(this);\n        this.#worker = worker;\n    }\n\n    /**\n     * Copy code from a block to the users clipboard.\n     *\n     * @param {HTMLElement} button The copy to clipboard button that was pressed.\n     * @returns {void} Used as a short circuit.\n     */\n    copyToClipboard(button) {\n        const table = button.nextElementSibling;\n        if (table.nodeName !== 'TABLE') { return; }\n        // Visually show the table is being copied.\n        button.ariaPressed = true;\n        table.classList.add('copy-to-clipboard');\n        // Actually copy the table to the users clipboard:\n        const cells = table.querySelectorAll('tr td:nth-child(2)');\n        // Copy data to a temporary div.\n        const tmpDiv = document.createElement('div');\n        cells.forEach((cell) => {\n            tmpDiv.textContent += `${cell.textContent}\\n`;\n        });\n        // Copy the text from the temporary div to the clipboard using the Clipboard API.\n        navigator.clipboard.writeText(tmpDiv.textContent.trimEnd())\n            .catch((error) => {\n                console.error('Failed to copy text to clipboard:', error);\n            });\n        // Remove the visual effect.\n        setTimeout(() => {\n            table.classList.remove('copy-to-clipboard');\n            button.ariaPressed = false;\n        }, 500);\n    }\n\n    /**\n     * Correct the padding of code blocks.\n     *\n     * @param {HTMLElement} elem The code element to process.\n     */\n    async #correctPadding(elem) {\n        // Enforce proper <pre><code> structure.\n        let pre;\n        let code;\n        if (elem.nodeName === 'PRE') {\n            // Correct pre element.\n            pre = elem;\n            code = elem.querySelector('code');\n            if (!code) {\n                // Incorrect code element.\n                code = document.createElement('CODE');\n                code.innerText = pre.innerText;\n                pre.innerHTML = '';\n                pre.appendChild(code);\n            }\n        } else if (elem.nodeName === 'CODE') {\n            // Correct code element.\n            pre = elem.closest('pre');\n            code = elem;\n            if (!pre) {\n                // Incorrect pre element.\n                pre = document.createElement('PRE');\n                code.parentElement.insertBefore(pre, elem);\n                pre.appendChild(code);\n            }\n        } else {\n            // Pre and code missing entirely.\n            pre = document.createElement('PRE');\n            code = document.createElement('CODE');\n            code.innerText = elem.innerHTML;\n            pre.appendChild(code);\n            elem.parentElement.insertBefore(pre, elem);\n            elem.parentElement.removeChild(elem);\n        }\n        // Don't waste time reprocessing a block.\n        if (code.classList.contains('fixed-padding')) { return; }\n        // Break the code into their lines for processing.\n        const lines = code.innerText.split('\\n');\n        /**\n         * Remove empty lines from the start and end of the code. We cannot\n         * use trim because it will wipe the indentation we are trying to find.\n         */\n        let startIndex = 0;\n        let endIndex = lines.length - 1;\n        // Find the index of the first non-empty line from the start.\n        while (startIndex < lines.length && lines[startIndex].trim() === '') {\n            startIndex += 1;\n        }\n        // Find the index of the first non-empty line from the end.\n        while (endIndex >= 0 && lines[endIndex].trim() === '') {\n            endIndex -= 1;\n        }\n        // Calculate the number of empty lines to remove from the start and end.\n        const numEmptyLinesAtStart = startIndex;\n        const numEmptyLinesAtEnd = lines.length - 1 - endIndex;\n        // Remove the empty lines from the start and end of the array.\n        lines.splice(0, numEmptyLinesAtStart);\n        lines.splice(lines.length - numEmptyLinesAtEnd, numEmptyLinesAtEnd);\n        // Just in case we were given a bad code block save it from erroring out here.\n        if (lines.length === 0) { lines.push(''); }\n        // Count the spaces from the first line, this indicates the indentation we need to remove.\n        const match = lines[0].match(/^\\s+/);\n        const indentation = match ? match[0].length : 0;\n        // Remove the unnecessary indentation (padding) at the start of each line.\n        lines.forEach((line, i) => {\n            lines[i] = line.substring(indentation);\n        });\n        // Make the replacement in the DOM and remove any extra empty new line at the end.\n        code.innerText = lines.join('\\n').trim();\n        code.classList.add('fixed-padding');\n        pre.innerHTML = pre.innerHTML.trim();\n    }\n\n    /**\n     * Disconnect from HLJSL's web worker.\n     *\n     * @returns {void} Used as a short circuit.\n     */\n    disconnect() {\n        if (!this.#worker) {\n            return;\n        }\n        this.#worker.terminate();\n        this.#worker = null;\n    }\n\n    /**\n     * Check the status of the page being auto loaded (processed).\n     *\n     * @returns {boolean} True if the primary HLJSL instance auto loaded (processed) the page.\n     */\n    getAutoRunStatus() {\n        return autoRunCompleted;\n    }\n\n    /**\n     * Build the querySelectorAll string to search and find all specified elements.\n     *\n     * @param {array} find An array of element tags, classes prefixed with the css dot (.), and/or\n     *                     ids prefixed with the css pound (#) to locate in the page.\n     *\n     * @returns {string} The querySelectorAll string to locate all your requested elements.\n     */\n    getQuerySelectorFindAllString(find = []) {\n        if (find.length === 0) { return ''; }\n        return find.join(', ');\n    }\n\n    /**\n     * Builds the query string meant to be used with querySelectorAll and allows not searching\n     * within classes, ids, and/or elements.\n     *\n     * @param {string} find The query selector you would like to find.\n     * @param {array} notWithin An array of element tags, classes prefixed with the css dot (.), and/or\n     *                          ids prefixed with the css pound (#) to not search in.\n     *\n     * @returns {string} The proper query selector string to use with querySelectorAll.\n     */\n    getQuerySelectorNotWithinString(find, notWithin = []) {\n        if (notWithin.length === 0) { return find; }\n        const ignoredSelectors = notWithin.join(', ');\n        return `:not(${ignoredSelectors}) > ${find}`;\n    }\n\n    /**\n     * Detect what language the user is viewing the page in.\n     *\n     * @returns {string} The users valid BCP 47 language code.\n     */\n    getUserLanguage() {\n        // Start with the browsers language setting.\n        let userLanguage = navigator.language || navigator.userLanguage;\n        // Check if lang attribute is set in the HTML tag.\n        const htmlLang = document.documentElement.lang;\n        if (htmlLang) {\n            // Check if the lang attribute is a valid BCP 47 language tag.\n            const langRegex = /^[a-zA-Z]{2}(-[a-zA-Z]{2})?$/;\n            if (langRegex.test(htmlLang)) {\n                // Use the language that the developer set instead.\n                userLanguage = htmlLang;\n            }\n        }\n        return userLanguage;\n    }\n\n    /**\n     * Share the version of HLJSL being used.\n     *\n     * @returns  {string} The current version on HLJSL.\n     */\n    getVersion() {\n        return this.#version;\n    }\n\n    /**\n     * Highlight a code element with HLJS using the HLJSL web worker.\n     *\n     * @param {HTMLElement} elem The code element to highlight.\n     */\n    async highlight(elem) {\n        // If the web worker is not connected do so now.\n        if (!this.isConnected()) {\n            /**\n             * NOTE: We do not connect automatically in case this page doesn't\n             * have any code blocks to highlight.\n             */\n            this.connect();\n        }\n        // Do not waste time reprocessing a block.\n        if (elem.hasAttribute('hljsl-id')) { return; }\n        /**\n         * This should have been added already but a deferred code block that the\n         * user wants to manually process will be missing this.\n         */\n        if (this.#hideNumbers) {\n            elem.parentElement.classList.add('hide-numbers');\n        }\n        await this.#correctPadding(elem);\n        /**\n         * This should have been added already but a deferred code block that the\n         * user wants to manually process will be missing this.\n         */\n        elem.parentElement.classList.add('hljs');\n        // eslint-disable-next-line no-param-reassign\n        elem.dataset.hljslId = this.createId();\n        const msg = {\n            code: elem.innerText,\n            codeLang: elem.classList.toString(),\n            id: elem.dataset.hljslId,\n            pageLang: this.#lang,\n            root: this.#root\n        };\n        // Message the web worker.\n        this.#worker.postMessage(JSON.stringify(msg));\n    }\n\n    /**\n     * Process all code blocks found within the provided container (element).\n     *\n     * @param {HTMLElement} container The code element to highlight.\n     */\n    highlightAll(container) {\n        // eslint-disable-next-line no-param-reassign\n        if (!container) { container = document; }\n        // Find all the code blocks in this element.\n        const codeBlocks = container.querySelectorAll('pre code');\n        codeBlocks.forEach((block) => {\n            // Process each code block found.\n            this.highlight(block);\n        });\n    }\n\n    /**\n     * Initializes HLJSL by determining its root location and checking for various options (settings).\n     */\n    #initialize() {\n        // Set the apps language.\n        this.#lang = this.getUserLanguage();\n        // Determine the root (directory) location of HLJSL.\n        this.#root = window?.location?.origin;\n        let hljsScriptSrc = '';\n        const scripts = document.getElementsByTagName('script');\n        for (let i = 0; i < scripts.length; i++) {\n            const { src } = scripts[i];\n            if (src.includes('/hljsl')) {\n                if (src.indexOf('?')) {\n                    hljsScriptSrc = src.substring(src.indexOf('?'));\n                }\n                this.#root = src.substring(0, src.indexOf('/hljsl'));\n                break;\n            }\n        }\n        // Check for and configure various options (settings).\n        const urlParams = new URLSearchParams(hljsScriptSrc);\n        if (urlParams.get('autoLoad')) {\n            this.#autoLoad = this.isTrue(urlParams.get('autoLoad'));\n        }\n        if (urlParams.get('hideNumbers')) {\n            this.#hideNumbers = this.isTrue(urlParams.get('hideNumbers'));\n        }\n        if (urlParams.get('lazyLoad')) {\n            this.#lazyLoad = this.isTrue(urlParams.get('lazyLoad'));\n        }\n    }\n\n    /**\n     * Check if HLJSL's Web worker is connected.\n     *\n     * @returns {boolean} Boolean indicating the web worker connection state; true is connected.\n     */\n    isConnected() {\n        return !(this.#worker === null);\n    }\n\n    /**\n     * Convert a string representing a boolean into an actual boolean.\n     *\n     * @param {string} str The string to convert to the correct boolean value.\n     * @returns\n     */\n    isTrue(str) {\n        if (typeof (str) === 'string') {\n            str = str.trim().toLowerCase();\n        }\n        switch (str) {\n            case true:\n            case 'true':\n            case 1:\n            case '1':\n            case 'on':\n            case 'yes':\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Automatically process code blocks according to the default or global settings.\n     */\n    #processBlocks() {\n        // We automatically fix all code block padding and show or hide line numbers no matter what.\n        document.body.querySelectorAll('pre code').forEach((block) => {\n            // Before fixing the padding check if we need to hide line numbers.\n            if (this.#hideNumbers) {\n                block.classList.add('hide-numbers');\n            }\n            this.#correctPadding(block);\n        });\n        // Now process the page according to the users settings.\n        const selector = this.getQuerySelectorNotWithinString('pre code', this.#ignoreElements);\n        const autoProcess = this.getQuerySelectorFindAllString(this.#onlyAutoProcess);\n        const elems = document.querySelectorAll(autoProcess);\n        elems.forEach((elem) => {\n            const blocks = elem.querySelectorAll(selector);\n            blocks.forEach(async (block) => {\n                block.parentElement.classList.add('hljs');\n                // Stop processing if autoLoad is false; we only fix the padding and spacing.\n                if (!this.#autoLoad) { return; }\n                // Process blocks now or lazy load them?\n                if (!this.#lazyLoad) {\n                    // Process blocks now.\n                    this.highlight(block);\n                    return;\n                }\n                // Lazy load blocks instead; recommended for pages with many code blocks.\n                const blockObserverOptions = {\n                    root: null,\n                    rootMargin: '100%',\n                    threshold: 0\n                };\n                const blockObserver = new IntersectionObserver(\n                    this.#blockInView.bind(this),\n                    blockObserverOptions\n                );\n                blockObserver.observe(block);\n            });\n        });\n    }\n\n    /**\n     * Receives the response from HLJSL's web worker.\n     *\n     * @param {MessageEvent} evt The response from HLJSL's web worker.\n     */\n    #receiveResponse(evt) {\n        const msg = JSON.parse(evt.data);\n        // Using the elements id to locate the actual element.\n        const elem = document.querySelector(`[data-hljsl-id=\"${msg.id}\"]`);\n        // Clean the response just in case an empty newline snuck in at the end.\n        elem.innerHTML = msg.code.trim();\n        // Place the code block on the same line as the pre block to remove those empty lines.\n        elem.parentElement.innerHTML = elem.outerHTML.trim();\n        /**\n         * Make sure the code block has a HLJS language tag. If it already does then this should be\n         * the same that was used during the processing. If you were missing the language tag this\n         * will be the language HLJS detected this code to be.\n         */\n        elem.classList.add(msg.language);\n    }\n\n    /**\n     * Allows changing the default settings being used by this instance of HLJSL.\n     *\n     * @param {object} config The settings you would like to set.\n     * @returns\n     */\n    setConfig(config) {\n        if (this.whatIs(config) !== 'object') { return; }\n\n        if (this.whatIs(config.autoLoad) === 'boolean') {\n            this.#autoLoad = config.autoLoad;\n        }\n\n        if (this.whatIs(config.hideNumbers) === 'boolean') {\n            this.#hideNumbers = config.hideNumbers;\n        }\n\n        if (this.whatIs(config.ignoreElements) === 'array') {\n            this.#ignoreElements = config.ignoreElements;\n        }\n\n        if (this.whatIs(config.lang) === 'string') {\n            this.#lang = config.lang;\n        }\n\n        if (this.whatIs(config.lazyLoad) === 'boolean') {\n            this.#lazyLoad = config.lazyLoad;\n        }\n\n        if (this.whatIs(config.onlyAutoProcess) === 'array') {\n            if (config.onlyAutoProcess.length > 0) {\n                this.#onlyAutoProcess = config.onlyAutoProcess;\n            }\n        }\n    }\n\n    /**\n     * Using a mutation observer watch for pre code blocks being added to the page\n     * and immediately start to process them.\n     */\n    #waitForBody() {\n        const bodyObserver = new MutationObserver((mutationList, observer) => {\n            for (let i = 0; i < mutationList.length; i++) {\n                const mutation = mutationList[i];\n                // Do no process unnecessary events; ignores attribute events.\n                if (mutation.type !== 'childList') {\n                    // eslint-disable-next-line no-continue\n                    continue;\n                }\n                // Skip all elements that are not the body.\n                if (mutation.target.nodeName !== 'BODY') {\n                    // eslint-disable-next-line no-continue\n                    continue;\n                }\n                /**\n                 * Stop the observer to reduce resource use on this page. If any\n                 * code blocks are added later the user will need to manually\n                 * call the `highlight` or `highlightAll` methods.\n                 */\n                observer.disconnect();\n                /**\n                 * Body element has been added to the DOM so search it and process\n                 * all the code blocks found inside it.\n                 */\n                this.#processBlocks();\n                return; // Kill the loop so we don't trigger another reprocessing!\n            }\n        });\n        // Start the observer.\n        bodyObserver.observe(document.documentElement, { childList: true, subtree: true });\n    }\n\n    /**\n     * The fastest way to get the actual type of anything in JavaScript.\n     *\n     * {@link https://jsbench.me/ruks9jljcu/2 | See benchmarks}.\n     *\n     * @param {*} unknown Anything you wish to check the type of.\n     * @return {string|undefined} The type in lowercase of the unknown value passed in or undefined.\n     */\n    whatIs(unknown) {\n        try {\n            return ({}).toString.call(unknown).match(/\\s([^\\]]+)/)[1].toLowerCase();\n        } catch (e) { return undefined; }\n    }\n\n}\n\n// Primary instance of HLJSL that auto precesses the page.\nwindow.hljsl = new HighlightLite();\n\n// Rollup will create an iife adding HighlightLite globally to the window as HLJSL.\nexport default HighlightLite;\n"],"names":["autoRunCompleted","HighlightLite","autoLoad","hideNumbers","ignoreElements","lang","lazyLoad","onlyAutoProcess","root","worker","version","constructor","config","this","initialize","Object","keys","length","checkForGlobalConfig","setConfig","waitForBody","blockInView","entries","observer","forEach","entry","isIntersecting","disconnect","highlight","target","globalConfig","window","hljslConfig","createId","Date","now","toString","Math","random","substring","toUpperCase","connect","Worker","onmessage","receiveResponse","bind","copyToClipboard","button","table","nextElementSibling","nodeName","ariaPressed","classList","add","cells","querySelectorAll","tmpDiv","document","createElement","cell","textContent","navigator","clipboard","writeText","trimEnd","catch","error","console","setTimeout","remove","async","elem","pre","code","querySelector","innerText","innerHTML","appendChild","closest","parentElement","insertBefore","removeChild","contains","lines","split","startIndex","endIndex","trim","numEmptyLinesAtStart","numEmptyLinesAtEnd","splice","push","match","indentation","line","i","join","terminate","getAutoRunStatus","getQuerySelectorFindAllString","find","getQuerySelectorNotWithinString","notWithin","getUserLanguage","userLanguage","language","htmlLang","documentElement","test","getVersion","isConnected","hasAttribute","correctPadding","dataset","hljslId","msg","codeLang","id","pageLang","postMessage","JSON","stringify","highlightAll","container","block","location","origin","hljsScriptSrc","scripts","getElementsByTagName","src","includes","indexOf","urlParams","URLSearchParams","get","isTrue","str","toLowerCase","processBlocks","body","selector","autoProcess","IntersectionObserver","rootMargin","threshold","observe","evt","parse","data","outerHTML","whatIs","MutationObserver","mutationList","mutation","type","childList","subtree","unknown","call","e","hljsl"],"mappings":"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"}